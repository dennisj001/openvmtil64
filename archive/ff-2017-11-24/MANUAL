            
                    
                    //  ) ) //  ) ) 
                 __//__  __//__     
                  //      //        
                 //      //         
                //      //     


    A traditional Forth system for UNIX and embedded systems



I. Introduction
---------------

This is `ff`, an implementation of the Forth programming language
for 32- and 64-bit CPUs on Linux, Mac OS X and most BSD flavors. `ff` is
indirect-threaded and currently available for x86_64, i386, ARM, MIPS,
PowerPC, m68k/ColdFire, RISC-V and Sparc processors. It is kept intentionally
simple to reduce size and complexity to a minimum. Floating-point math and
double-precision numbers are not directly supported and only basic I/O
facilities are provided. On the other hand, the machine-code portion is
small and it should be very easy to port `ff` to other architectures. `ff`
is completely self-contained - no additional software is needed to build
it and the system can be cross-compiled from and to all supported target
platforms.  The C library (`libc`) is not used, `ff` directly invokes
Linux or BSD system-calls or can be modified to directly access the hardware
on bare metal systems.

Note that `ff` is not related to or derived from FreeForth[10]


II. Portability
---------------

`ff` currently supports the following operating systems and processor
architectures:

    Arch / OS   | Linux | NetBSD | FreeBSD | OpenBSD | Darwin
    ------------+-------+--------+---------+---------+--------
    arm         |   X   |   ?    |    ?    |    ?    |   -
    armeb       |   X   |   ?    |    ?    |    ?    |   -
    coldfire    |   X   |   ?    |    -    |    -    |   -
    i386        |   X   |   ?    |    ?    |    ?    |   ?
    m68k        |   ?   |   ?    |    -    |    -    |   -
    mips        |   1   |   ?    |    ?    |    ?    |   -
    mipsel      |   1   |   ?    |    ?    |    ?    |   -
    mipsn32     |   1   |   ?    |    ?    |    ?    |   -
    mipsn32el   |   1   |   ?    |    ?    |    ?    |   -
    ppc         |   X   |   ?    |    ?    |    ?    |   -
    riscv32     |   X   |   ?    |    -    |    -    |   -
    riscv64     |   ?   |   ?    |    -    |    -    |   -
    sparc       |   X   |   ?    |    -    |    -    |   -
    x86_64      |   X   |   ?    |    ?    |    ?    |   2

    X: fully working
    -: not implemented
    1: mmap (syscall6) is currently broken
    2: `ms` is not yet implemented and currently a no-op
    ?: status unknown

Configurations marked "?" (unknown) in the table above should work in
theory, but haven't been tested yet.


III. Platform notes
-------------------

- On x86_64 cell size is 8, on all other architectures it is 4.

- Cross-compilation of `ff-x86_64-darwin` requires a 64-bit host
  binary.

- The Darwin build has only been fully tested on OS X "Sierra" so far
  and the `ff-i386-darwin` seems not to load correctly on this
  version.

- The m68k kernel uses 32-bit division/remainder and thus requires
  an 68020 or higher.


IV. Installation
----------------

See the `README` file in the distribution archive for installation
instructions.


V. Usage
--------

`ff` reads Forth commands from stdin, interpreting words as they are parsed. A 
subset of the [Forth ANSI standard][3] is supported, see below for a 
description of all words that are available. 

The `forth` script implements a simple text-based front-end for `ff`, and is 
written in Tcl/Tk. It provides a very basic terminal and implements simple
text-editing functionality. It defaults to invoking a binary named `ff` which 
should be in the `PATH` (if it isn't, copy or symlink the `ff-*` binary for your 
architecture.)

Command-line options that the `forth` script accepts:

    -background COLORNAME          select background color
    -foreground COLORNAME          select foreground color
    -fontname FONTNAME             select font
    -fontsize FONTSIZE             select fontsize
    -execute FILENAME              load Tcl source from FILENAME at startup
    -ff FILENAME                   run FILENAME instead of the default "ff"
    -cd DIRECTORY                  change working directory to DIRECTORY
    -init STRING                   Forth code to be executed on startup
    -nohistory                     do not log input to history file
                                   (defaults to "~/.forth-history.txt")

Output from `ff` is appended to any text in the window. The character `^L` 
(ASCII 12) is handled specially and clears the window.  

`RETURN` will send the current selection to the Forth interpreter, or the 
current line if no text is currently selected. Pressing the `Insert` key will 
enter *hold* mode, which means `RETURN` will just insert a newline, without 
executing any code. Pressing `Insert` again will send all text beginning from 
the location where `Insert` was first pressed up to the current cursor position 
and disable hold mode. 

Pressing the right mouse button on a word in the window will execute the Forth 
statement `command <word>`. `command` is a deferred word defined in `stuff.f` 
that can be used to implement a poor man's menu system by just right-clicking 
words in the window. 

Pressing `Escape` terminates the Forth interpreter, pressing it again exits
the front-end.

The function keys can be bound to text that is either inserted at the current
position, or (if it ends with a newline) immediately executed. To bind a key to
a particular sequence, select the text you want to bind and press `Control-F<n>`,
where `F<n>` is the function key you want to change.

`Control-Up` and `Control-Down` allow moving through a history of already
entered lines. The history file is persistent and by default located in
`~/.forth-history.txt`, or in the current directory, if it already exists.

`Alt-Up` and `Alt-Down` move the currently shown screen, when the
block and editor extensions are loaded.

If a file called `.forth` exists in the `HOME` directory, it is loaded before 
startup and can be used to customize the front-end. Study the source code for 
`forth` to learn more about it. 

If the Forth system crashes, the background color turns to black and a message 
is printed. Press `RETURN` to restart. 

A special command is provided to send files directly as terminal input to
the forth executable. It is named `transmit` and expects a filename given
on a single lime:

    transmit FILENAME

This facility allows loading files via the interactive interface and
so will work on systems that have not access to a file system or are
accessed remotely.


VI. Unicode support
-------------------

Partial UTF-8 support is provided: `emit`, `char` and `[char]` encode and
decode UTF-8 sequences correctly, `key` does not. The front-end allows
entering unicode code-points using the `Ctrl-q` key, which accepts either
a hexadecimal code-point or a named character. The latter can be defined
in your `~/.forth` file by adding a Tcl definition for the `snippets`
variable, holding lists of 2-element lists:


    set snippets {
      {alpha "\u03b1"}
      ...
    }


VII. Builtin words
------------------

`ff` tries to adhere to the Forth200x standard where it seemed to
make sense. Most core and core-extension words are provided, together
with many file- and string- words. The list of supported words further
down lists all words provided by the core system and the extensions in
the file `stuff.f`.

Floating-point words are not provided. Also, number parsing and
printing only support single-precision numbers.

Note again the `ff` is case-sensitive and that standard words are all
meant to be used in lowercase.

- Words incompatible to the Forth200x standard:

    `literal` and `sliteral` are not immediate. It is not clear where
    the advantage lies in making these so.

    `c"` is intended for interpretation time, and should not be used
    in colon definitions.

    `create` does not work in combination with `does>`, use `<builds`
    (described below) instead.

    `parse` returns a counted string, not an address + length.

    `abort` and `abort"` do not throw exceptions and can not be caught.
    The standard semantics are rather messy, and catching aborts can
    be handled much easier by modifying the deferred word `abort`

    `(` does not allow comments that exceed the current line.

- Useful non-standard core words

    `2nip           ( x y z q -- z q )`

    Drops the 3nd and 4th items on the stack.

    `<builds        ( | <word> -- )`

    Compile-time part of `<builds ... does>` pair. In other Forth systems
    `create` is normally used for this, but to avoid depending on creating
    native code on the fly, a special word is used instead.

    `>limit         ( -- a )`

    Variable holding the end-index in the text-input-buffer (TIB).

    `?stack         ( -- )`

    Aborts on stack-underflow.

    `(.)            ( n1 -- a n2 )`

    Convert signed number to string and return address and length.

    `#arg           ( -- u )`

    Pushes the number of command-line arguments given to the executable
    (including the program name.)

    `arg            ( u1 -- a u2 )`
    
    Pushes address and length of the `u1`th command line argument
    (argument #0 is the program name.)

    `boot           ( ... -- )`

    Completely reinitializes the system and invokes `cold`.

    `brk            ( -- )`

    Invokes the debugger, if the executable is running under one, or
    invokes a software trap, depending on architecture and operating
    system.

    `bye            ( -- )`

    Terminates `ff`. This is a deferred word.

    `cold           ( ... -- )`

    Performs a "cold" start, completely re-initializing the system.

    `crash          ( ... -- )`

    Called when an uninitialized deferred word is invoked.
 
    `halt           ( n -- )`

    Terminate with exit-code `n`.

    `interpret      ( | ... -- )`

    Interprets words from the text-input-buffer (TIB).

    `number         ( a n1 -- n2 -1 | a n1 0 )`

    Parses number given by string and either pushes the parsed
    number and `true` or keeps the argument items, pushing `false`,
    if the number is not a valid integer. Not ANS compatible, because
    it only handles single-precision numbers.

    `lock?          ( a -- f )`

    Try to set the byte or word at address `a`, and return true if setting
    the lock was successful (i.e. the lock was not already set.) This
    operation is atomic and can be used to implement spin-locks. The
    actual lock value may be a byte or a word, depending on architecture.
    Testing the lock can be done by fetching a word from the address of
    the lock and checking it to be non-zero. Clearing the lock is done
    by storing a zero word.

    `prompt         ( -- )`

    A deferred word that prints the prompt that is shown when the
    interpreter waits for input. The default prints ` ok` and advances
    to a new line.

    `query          ( -- )`

    Reads a new line from stdin into the TIB.

    `reveal         ( -- )`

    Exposes the most recent item in the dictionary (see also
    `smudge`.)

    `rshifta        ( n1 n2 -- n3 )`

    Performs an arithmetic shift of `n1` by `n2` bits.

    `rp!            ( a -- )`

    Sets the return-stack pointer to `a`.

    `rp@            ( a -- )`

    Pushes the current return-stack pointer.

    `r0             ( -- a )`

    Variable holding the initial return-stack pointer.

    `sp!            ( a -- )`

    Sets the stack pointer to `a`.

    `sp@            ( -- a )`

    Pushes the current stack pointer.

    `s0             ( -- a )`

    Variable holding the initial stack-pointer.

    `signum         ( n1 -- n2 )`

    Pushes -1, 0 or 1, depending on whether `n1` is negative, zero
    or positive.

    `smudge         ( -- )`

    Hides the most recent dictionary entry.

    `transmit       ( u -- )`

    Reads the given number of bytes from standard input and evaluates
    the result.

    `utfdecode      ( a1 -- a2 c )`

    Decodes the UTF-8 byte sequence at address `a1` and returns the address
    directly after the byte sequence and the unicode code-point.

    `utfencode      ( a c -- a n )`

    Encodes the unicode code-point `c` as an UTF-8 byte sequence at address
    `a`, and returns the target address and the number of bytes.

    `version`       ( -- u )`

    Pushes the version of of executing binary, which is increased every
    time the core system is metacompiled.

- Optional words

  Some additional standard and non-standard words are available in the 
  source file `stuff.f`.

- Internal words

  `ff` provides many more words that are used internally and might be 
  useful. Consult the file `core.f` for more information. Note that these
  internal words may be changed or removed between releases.
  

VIII. The Block-file Editor
---------------------------

The system includes an optional simple command-based block-editor in
the file `ed.f`.  See below for a list of available editor
commands. Blocks are stored in a file called `blockfile`, which must
reside in the current working directory. Note that the editor needs
the words in `blocks.f`.

To create a blockfile, use the following commands

    # creates a blank file of 1024 blocks:
    dd if=/dev/zero bs=1024 count=1024 | tr '\000' ' ' >blockfile

The editor maintains two buffers, together with the current edited
block (`scr`): the *insertion-buffer* and the *find-buffer*. The
former is used in commands that add or insert text, the latter holds
text that is searched.

The editor is provided in source form in the file `ed.f`. The
ANS block- and buffer-related words can be found in `blocks.f`.

All editor words exist in the `editor` vocabulary, so execute 
`also editor` before using them, to make the editor words visible in
the search order.

- Editor commands:

    `b              ( -- )`

    List previous screen.

    `copy           ( n1 n2 -- )`

    Copies contents of block `n1` to block `n2`.

    `cut            ( -- )`

    Deletes everything on the line, starting from the current
    position.

    `d              ( [| ...] -- )`

    Deletes given text (or last found text).

    `e              ( -- )`

    Deletes last found text.

    `f              ( [| ...] -- )`

    Searches given text (or contents of the find-buffer) in current
    line.

    `i              ( [| ...] -- )`

    Inserts given text (or contents of the insert-buffer) at current
    position.

    `index          ( n1 n2 -- )`

    Shows first lines of blocks in given range.

    `k              ( -- )`

    Swaps contents of insert- and find-buffer.

    `l              ( -- )`

    Clears window and lists current screen.

    `n              ( -- )`

    Lists next screen.

    `p              ( [| ...] -- )`

    Replaces current line with given text (or contents of the
    insert-buffer).

    `r              ( [| ...] -- )`

    Replaces last found text with given text (or contents of the
    insert-buffer).

    `s              ( n [| ...] -- n )`

    Searches given text (or contents of find-buffer) in current
    screen and all blocks up to and including `n`.

    `show           ( n1 n2 -- )`

    Lists blocks in the given range.

    `t              ( n -- )`

    Selects line `n`.

    `till           ( [| ...] -- )`

    Erases all text from the current position to the position where
    the given text (or the contents of the find-buffer) is found in
    the current line.

    `u              ( [| ...] -- )`

    Inserts given text (or contents of insert-buffer) below the
    current line, shifting remaining lines down.

    `wipe           ( -- )`

    Blanks the current screen.

    `x              ( -- )`

    Removes current line and stores it in the insertion-buffer, scrolls
    lines below up.


IX. Debugging Tools
-------------------

To help in program development, the files `decomp.f` and `dbg.f`
provide a simple decompiler and a debugger for compiled Forth code.

- Decompiling

  Use `see <word>` to obtain a description of a named Forth entity.
  For colon words and words defined with `<builds ... does>` `see`
  will list their compiled code, albeit a low-level representation of
  it.

  `where <word>` lists all colon definitions visible in the current
  search list that contain a referent to `<word>`.

- Debugging

  The debugger executes colon-words by interpreting the compiled code
  and is started by entering `debug <word>`. To use it, load `dbg.f`
  and add the `debugger` vocabulary to the search order:

        include dbg.f
        also debugger

  The debugger is used from the toplevel interpreter and maintains
  an execution state separate from normal execution of the outer and
  inner interpreters. Once started, the prompt is changed and shows
  the current state, like this:

        DEBUG: (<R>) <IP> <OP> | <STACK>

  `<R>` is the current (simulated) return-stack depth, `<IP>` is the
  address of the next instruction to be executed (`<OP>`), followed by
  the contents of the data stack.

  The debugger maintains it's own return stack, but uses the normal
  data stack, allowing arbitrary stack manipulations between each
  operation executed while the debugger is active.

- Debugger commands:

    `debug          ( | <word> -- )`

    Start debugging `<word>`. If another definition was currently 
    executing under debugger-control, then the previous execution is
    quietly aborted.

    `q              ( -- )`

    Stop debugging. The contents of the data stack remain unchanged.

    `s              ( -- )`

    Execute the next instruction.

    `n              ( -- )`

    Execute the next instruction and, if it is a colon word, continue 
    executing it until it returns. Note that execution of nested words
    is much slower when it takes place under debugger control.

    `t              ( -- )`

    Like `n`, but show each instruction as it is executed.

    `.rs            ( -- )`

    Show the contents of the (simulated) return stack.


X. Saving executables
---------------------

The files `unexec-elf.f` and `unexec-a.out.f` contain words to save the 
currently running executable to an elf[6] or a.out[9] binary. To save 
the current state, enter

    save <filename>

The deferred word `startup` can be changed to point to a word that
should be invoked when the executable starts, the default is to
enter the interactive state.


XI. Assemblers
--------------

The distribution contains assemblers for some of the target
architectures. Please consult the files `<ARCH>/asm.f` for more
information on how to use them. All assemblers provide the words
`code` and `end-code` to define words written in machine language. See
`<ARCH>/kernel.f` and the comments in `<ARCH>/asm.f` for examples on
how to use them.

No automatic instruction-cache flushing is performed. On architectures
that require this, you will have to implement the necessary operations
yourself.

`i386/asm.f` originates from kForth[7] and was written by Frank Sergeant,
and subsequently extended by Thomas Novelli and Krishna Myneni. This
code is available under a MIT/BSD license.

Note that this assembler contains a number of bugs: indirect addressing 
with register `esp` and indirect jump through a register result in an
incorrect instruction encoding.

`arm/asm.f` was written by J.D. Medhurst (see here[8]) and is available
under a MIT license.


XII. Porting Guide
------------------

Porting `ff` to a new architecture requires implementing a code generator
for "generic", a pseudo machine level Forth in that the kernel containing
the machine-language primitives is written in. Generic has words for
explicit stack access and consists of machine code templates that are
used to construct the core dictionary. See `<ARCH>/generic.f` for many
examples for already supported architectures.

Support for a new operating system is accomplished by adding a file
`<ARCH>/<OS>.f` holding OS-specific definitions required by the words
defined in `core.f`. Some core words have to be defined to connect
the I/O primitives with the outside world, read `unix.f` and `bare.f`
for more information.

Provided the necessary files are added and follow the given naming
convention, you can then invoke `metacompile` with the proper arguments:

    metacompile -arch ARCH -os OS -format FORMAT

New file formats can be implemented as well, study `elf.f`, `macho.f`,
`flat.f` or `multiboot.f` to understand the hooks that need to be defined.

One more customization option is the so-called "startup" file, that holds
OS-specific initialization code used to boot up the system. `startup.f`
is the minimal boot code, you can add custom initialiazion code there
and invoke it from `boot`.


XIII. Running on Bare Metal
---------------------------

`ff` supports generation of "flat" files that can be loaded directly
into a specific memory location and have no further structure. The
`-base` option for `metacompile` allows to set the base address of the
generated image. Again, I/O hooks need to be defined for the in your
startup code. The development repository[5] contains some example code
to run a minimal interactive 32-bit i386 `ff` core an raw PC hardware (or
emulation) by using a multiboot binary that can be booted by GRUB[12]. To
build and run it, assuming you have downloaded the repository, execute
these shell commands in the toplevel directory of the cloned repository:

    ./metacompile -arch i386 -os none -startup misc/pc \
      -format multiboot -o ff.bin -no-utf
    ./makeiso
    qemu-system-i386 -cdrom ff.iso

Note that a metacompiled binary only contains the primitve and core 
word sets. To use the optional words like those in `stuff.f`, a running
system is required that can load source code from files or blocks.
For this some sort of file-system interface is required.


XIV. Tips and Tricks
--------------------

- By using the `-ff` front-end option, nothing prevents you from
  invoking a forth-interpreter on another machine:

        forth -ff "ssh <remotemachine> ff"

  Alternatively, put this into your `~/.forth`:

        set forth "ssh <remotemachine> ff"

- The initial heap/dictionary space is allocated to 4 MB (including 
  the data- and return-stacks.) To change this setting, specify the 
  heapsize usiung the `-heapsize` option when invoking the
  `metacompile` script. Further customization can be done by modifying
  the script itself.

- Don't use tab (ASCII 9) characters - they are not treated as
  whitespace characters and will result in obsscure error messages.


XV. Glossary of all available words
-----------------------------------

    !              ( x a -- )                       primitive
    !+             ( a1 x -- a2 )                   optional

    ?exit          ( f -- )                         optional

    "              ( ..." -- a n )                  

    #              ( u1 -- u2 )                     
    #>             ( u1 -- a n )   
    #arg           ( -- u )                 
    #s             ( u -- n )                       

    '              ( <word> -- xt )                 

    (              ( ...) -- )         immediate    
    (+loop)        ( n -- )                         primitive
    (:)            ( -- )                           primitive
    (.)            ( n1 -- a n2 )                   
    (?abort)       ( f a n -- )
    (abort)        ( ... -- )
    (constant)     ( -- x )                         primitive
    (deferred)     ( -- )                           primitive
    (do)           ( n1 n2 -- )                     primitive
    (else)         ( -- )                           primitive
    (if)           ( n1 -- )                        primitive
    (literal)      ( -- n )                         primitive
    (loop)         ( -- )                           primitive
    (sliteral)     ( -- a n )                       primitive
    (variable)     ( -- a)                          primitive

    *              ( n1 n2 -- n3 )                  primitive

    +              ( n1 n2 -- n3 )                  primitive
    +!             ( n a -- )
    +field         ( u | <word> -- )                optional
    +loop          ( n -- )            immediate

    ,              ( x -- )
    ,"             ( | ..." -- )                    optional

    -              ( n1 n2 -- n3 )                  primitive
    -rot           ( x y z -- z x y )               
    -trailing      ( a n1 -- a n2 )                 optional

    .              ( n -- )
    ."             ( | ..." -- )       immediate
    .(             \( | ...) -- )      immediate    optional
    .buffers       ( -- )                           optional
    .rs            ( -- )                           debugger
    .s             ( -- )
    .r             ( n1 n2 -- )

    /              ( n1 n2 -- n3 )                  
    /mod           ( n1 n2 -- n3 n4 )               primitive
    /string        ( a1 n1 n2 -- a2 n3 )            optional

    0>             ( n -- f)                        optional
    0<             ( n -- f )
    0<>            ( n -- f )                       optional
    0=             ( n -- f )

    1+             ( n1 -- n2 )
    1-             ( n1 -- n2 )
    2*             ( n1 -- n2 )
    2/             ( n1 -- n2 )
    2@             ( a -- x y )
    2!             ( x y a -- )
    2>r            ( x y -- )
    2constant      ( x y | <word> -- )              optional
    2drop          ( x y -- )
    2dup           ( x y -- x y x y )
    2literal       ( x y -- )                       optional
    2nip           ( x y z q -- z q )
    2over          ( x y z q -- x y z q x y )
    2r>            ( -- x y )
    2r@            ( -- x y )                       optional
    2rot           ( x y z q v w -- z q v q x y )
    2swap          ( x y z q -- z q x y )
    2variable      ( | <word> -- )                  optional

    :              ( | <word> -- )
    :noname        ( | ... -- xt )                  optional

    ;              ( -- )              immediate

    <              ( n1 n2 -- f )                   primitive
    <#             ( -- )
    <=             ( x y -- f )                     optional
    <>             ( n1 n2 -- f )
    <builds        ( | <word> -- )

    =              ( n1 n2 -- f )                   primitive

    >              ( n1 n2 -- f )                  
    >=             ( x y -- f )                     optional
    >body          ( a1 -- a2 )
    >in            ( -- a )
    >limit         ( -- a )
    >r             ( x -- )                         primitive

    ?              ( a -- )
    ?do            ( n1 n2 -- )
    ?dup           ( x -- x [x] )
    ?stack         ( -- )

    @              ( a -- x )                       primitive
    @+             ( a1 -- a2 x )                   optional

    [              ( -- )
    [']            ( | <word> -- xt )  immediate
    [char]         ( | <char> -- c )   immediate
    [defined]      ( | <word> -- f )   immediate    optional
    [else]         ( | ... -- )        immediate    optional
    [if]           ( f | ... -- )      immediate    optional
    [then]         ( -- )              immediate    optional
    [undefined]    ( | <word> -- f )   immediate    optional

    \              ( | ... -- )        immediate

    ]              ( -- )              immediate

    a/o            ( -- n )
    abort          ( ... -- )          deferred
    abort"         ( f | ..." -- )     immediate
    abs            ( n -- u )
    accept         ( a n1 -- n2 )
    again          ( -- )              immediate
    align          ( -- )
    aligned        ( a1 -- a2 )
    allot          ( n -- )
    also           ( -- )                           optional
    and            ( n1 n2 -- n3 )                  primitive
    arg            ( u1 -- a u2 )

    b              ( -- )                           editor
    base           ( -- a )
    begin          ( -- )              immediate
    begin-structure ( | <word> -- a 0 )             optional
    bl             ( -- c )
    blank          ( a n -- )
    blk            ( -- a )
    block          ( n -- a )
    boot           ( -- )
    brk            ( -- )
    bounds         ( a1 n -- a2 a1 )                optional
    buffer         ( n -- a )
    buffer:        ( n | <word> -- )                optional
    bye            ( -- )              deferred

    c!             ( c a -- )                       primitive
    c,             ( c -- )
    c@             ( a -- c )                       primitive
    c"             ( | ..." -- a )                  
    callback       ( a -- )                         optional
    case           ( x -- )                         optional
    catch          ( xt -- exn# | 0 )               optional
    cell+          ( a1 -- a2 )
    cells          ( n1 -- n2 )
    cfield:        ( u1 | <name> -- u2 )            optional
    char           ( | <char> -- c )
    clear          ( ... -- )                       primitive
    close-file     ( fd -- ior )
    cmove          ( a1 a2 n -- )                   primitive
    cmove>         ( a1 a2 n -- )                   primitive
    cold           ( ... -- )         
    command        ( | <word> -- )     deferred     optional
    compare        ( a1 n1 a2 n2 -- n3 )
    constant       ( x | <word> -- x )
    context        ( -- a )                         optional
    copy           ( n1 n2 -- )                     editor
    count          ( a1 -- a2 n )
    cr             ( -- )
    crash          ( -- )
    create         ( | <word> -- )
    create-file    ( a n fam -- fd ior )
    current        ( -- )                           primitive
    cut            ( -- )                           editor

    d              ( | ... -- )                     editor
    d#             ( | <number> -- n ) immediate*   optional
    debug          ( | <word> -- )                  debugger
    debugger       ( -- )                           debugger
    decimal        ( -- )
    defer          ( | <word> -- )
    defer!         ( xt1 xt2 -- )
    defer@         ( xt1 -- xt2 )
    definitions    ( -- )                           optional
    delete-file    ( a n -- ior )
    depth          ( -- u )
    do             ( n1 n2 -- )        immediate
    does>          ( | ... -- a )
    dp             ( -- a )                         primitive
    drop           ( x -- )                         primitive
    dump           ( a n -- )
    dup            ( x -- x x )                     primitive

    e              ( -- )                           editor
    editor         ( -- )                           editor
    else           ( -- )              immediate
    emit           ( c -- )
    emits          ( c n -- )
    empty-buffers  ( -- )
    endcase        ( -- )                           optional
    endof          ( -- )                           optional
    end-structure  ( a offset -- )                  optional
    erase          ( a n -- )
    evaluate       ( a u -- )
    exec           ( a u -- )                       optional
    execute        ( xt -- )                        primitive
    exit           ( -- )                           primitive

    f              ( | ... -- )                     editor
    false          ( -- 0 )
    file-size      ( fd -- n ior )                  optional
    field:         ( u1 | <name> -- u2 )            optional
    fill           ( a n c -- )
    find           ( a -- a 0 | xt 1 | xt -1 )
    flush          ( -- )
    fork           ( -- pid|0 )                     optional
    forth          ( -- )                           optional
    forget         ( | <word> -- )                  optional

    h              ( -- a )                         primitive
    h#             ( | <number> -- n ) immediate*   optional
    halt           ( n -- )                         primitive
    here           ( -- a )
    hex            ( -- )
    hold           ( c -- )

    i              ( -- n )                         primitive
    i              ( | ... -- )                     editor
    if             ( f -- )            immediate
    immediate      ( -- )
    include        ( | <fname> -- )
    include-file   ( fd -- )
    included       ( a u -- )
    index          ( n1 n2 -- )
    interpret      ( -- )
    invert         ( n1 -- n2 )                     
    is             ( xt | <word> -- )  immediate*

    j              ( -- n )                         primitive
    join           ( -- )                           editor 

    k              ( -- )                           editor
    key            ( -- c )

    l              ( -- )                           editor
    list           ( n -- )                         editor
    literal        ( n -- )
    load           ( n -- )                         editor
    lock?          ( a -- f )                       primitive
    loop           ( -- )              immediate
    lshift         ( n1 u -- n2 )                   primitive

    map-file       ( fd acc size off -- a ior )     optional
    map-memory     ( size -- a ior )                optional
    max            ( n1 n2 -- n1 | n2 )
    marker         ( | <word> -- )                  optional
    min            ( n1 n2 -- n1 | n2 )
    mmap           ( a1 -- a2 )                     primitive
    mod            ( n1 n2 -- n3 )
    ms             ( n1 -- )                        optional

    n              ( -- )                           editor
    n              ( -- )                           debugger
    negate         ( n1 -- n2 )
    next-screen    ( -- )                           optional
    nip            ( x y -- y )
    noop           ( -- )                           optional
    number         ( a n1 -- n2 -1 | a n1 0 )

    of             ( x -- )                         optional
    off            ( a -- )
    on             ( a -- )
    only           ( -- )                           optional
    open-file      ( a n acc -- fd ior )
    or             ( n1 n2 -- n3 )                  primitive
    order          ( -- )                           optional
    over           ( x y -- x y x )                 primitive

    p              ( | ... -- )                     editor
    pad            ( -- a )
    page           ( -- )
    parse          ( c | ... -- a )
    pause          ( -- )                           primitive
    perform        ( a -- )                         optional
    postpone       ( | <word> -- )                  optional
    pick           ( ... n -- x )
    previous       ( -- )                           optional
    previous-screen ( -- )                          optional
    prompt         ( -- )               deferred

    q              ( -- )                           debugger
    query          ( -- )
    quit           ( ... -- )           deferred

    r              ( | ... -- )                     editor
    r0             ( -- a )                         primitive
    r/a            ( -- n )
    r/o            ( -- n )
    r/w            ( -- n )
    r>             ( -- x )                         primitive
    r@             ( -- x )                         primitive
    random         ( -- n )                         optional
    randomize      ( -- )                           optional
    read-file      ( a n1 fd -- n2 ior )
    recurse        ( -- )
    refill         ( -- f )
    repeat         ( -- )              immediate
    reposition-file ( n fd -- ior )
    reset          ( -- )                           primitive
    restore-input  ( ... n -- )
    reveal         ( -- )
    rfind          ( xt -- a|0 )                    optional
    roll           ( x1 x2 ... xN u -- x2 ... xN x1 ) optional
    rot            ( n1 -- n2 )
    rp!            ( a -- )                         primitive
    rp@            ( -- a )                         primitive
    rshift         ( n1 u -- n2 )                   primitive
    rshifta        ( n1 u -- n2 )                   primitive

    s              ( n | ... -- n )                 editor
    s              ( -- )                           debugger
    s"             ( | ..." -- a n )   immediate
    s0             ( -- a )                         primitive
    save           ( | <fname> -- )                 optional
    save-input     ( -- ... n )
    saved          ( a n -- )                       optional
    scan           ( a1 n1 c -- a2 n2 )             optional
    scr            ( -- a )                         editor
    search         ( a1 n1 a2 n2 -- a3 n3 f )
    see            ( | <word> -- )                  optional
    seed           ( -- a )                         optional
    show           ( n1 n2 -- )                     editor
    sifting        ( | <word> -- )                  optional
    sign           ( n -- )
    signum         ( n1 -- n2 )
    sizeof         ( | <word> -- sz )  immediate*   optional
    skip           ( a1 n1 c -- a2 n2 )             optional
    sliteral       ( a n -- )
    smudge         ( -- )
    source         ( -- a u )
    source-id      ( -- id )
    sp!            ( a -- )                         primitive
    sp@            ( -- a )                         primitive
    space          ( -- )
    spaces         ( n -- )
    startup        ( -- )              deferred
    state          ( -- a )
    string,        ( a n -- )                       optional
    swap           ( x y -- y x )
    syscall0       ( u -- x )                       primitive
    syscall1       ( x u -- y )                     primitive
    syscall2       ( x1 x2 u -- y )                 primitive
    syscall3       ( x1 x2 x3 u -- y )              primitive
    syscall4       ( x1 x2 x3 x4 u -- y )           primitive
    syscall6       ( a u -- x )                     primitive
    system         ( a u1 -- u2 )                   optional

    t              ( n -- )                         editor
    t              ( -- )                           debugger
    then           ( -- )              immediate
    th             ( a n1 -- n2 )                   optional
    throw          ( ... n -- ... | ... n )         optional
    thru           ( n1 n2 -- )                     editor
    tib            ( -- a )
    till           ( | ... -- )                     editor
    transmit       ( u -- )
    true           ( -- -1 )
    tuck           ( x y -- y x y )                 optional
    type           ( a n -- )

    u              ( | ... -- )                     editor
    u>             ( u1 u2 -- f )              
    u<             ( u1 u2 -- f )                   primitive
    u.             ( u -- )
    u.r            ( u n -- )
    under+         ( n1 n2 n3 -- n4 n2 )            optional
    unloop         ( -- )              immediate    primitive
    unmap-memory   ( a u -- ior )                   optional
    until          ( f -- )            immediate
    unused         ( -- u )  
    update         ( -- )
    utfdecode      ( a1 -- a2 c )
    utfencode      ( a c -- a n )
    utfparse       ( c | ... -- a )                 optional

    variable       ( | <word> -- )
    vocabulary     ( | <word> -- )                  optional

    w/o            ( -- n )
    waitpid        ( pid -- status ior )            optional
    where          ( | <word> -- )                  optional
    while          ( f -- )            immediate
    wipe           ( -- )                           editor
    within         ( n1 n2 n3 -- f )
    word           ( c | <word> -- a )
    words          ( -- )                           optional
    write-file     ( a n fd -- ior )

    x              ( -- )                           editor
    xor            ( n1 n2 -- n3 )


    (Words marked by `*` are state-smart)


XVI. Common error messages
--------------------------

- "<WORD> ?" Indicates that a word could not be found in the dictionary,
  either during interpretation or compilation.

- "stack underflow" The stack was exhausted while being popped.

- "unable to restore input" After including a file, the original
  input source could not be restored - usually, the case when the
  stack is unbalanced after inclusion fo the file.

- "uninitialized execution vector" A deferred word was invoked, that
  was not set yet using `is`.

- "too many wordlists" Too many vocabularies are active at the same
  time.

- "bad number syntax" Arguments given to `h#` or `d#` are syntactically
  invalid for the assumed base.

- "out of space" The last explicit or implicit `allot` would exhaust
  the available dictionary space.

- "no handler" A `throw` occurred without an enclosing `catch`.

- "unexpected end of input" unterminated interpreter conditional
  (like `[if]`).


XVII. Limits
------------

The default free dictionary space is 4MB, the default stack size is
4086 cells and the default return-stack size is 256 cells. These settings
can be changed by modifying the appropriate constants at the head of the
`metacompile` script.

UTF-8 encoded characters of maximally 4 bytes are supported, using
code-points that require more bytes result in undefined behaviour.

Words in the dictionary are significant to 31 characters.


XVIII. Frontend Key-bindings 
----------------------------

The key-bindings match mostly the standard key-bindings in Tcl/Tk's `text`
widget:

    Delete                 Toggle "hold" mode
    <Arrow>                Move insertion point
    Sh-<Arrow>             Move insertion point + extend selection
    C-Left, C-Right        Move insertion point by words
    C-Sh-Left, C-Sh-Right  Move insertion point by words + extend selection
    C-Sh-Up, C-Sh-Down     Move by paragraphs + extend selection
    Next, Prior            Move vertically one screenful
    Sh-Next, Sh-Prior      Move screenful + extend selection
    C-Next, C-Prior        Move horizontally one page without changing point
    C-a                    Move to beginning of line
    Home                   Move to beginning of text
    C-e                    Move to end of line
    End                    Move to end of text
    C-Space                Set selection anchor
    C-Sh-Space             Select from anchor to insertion point
    C-/                    Select all text
    C-d                    Delete selection or one character
    Backspace              Delete selection or last character
    M-d                    Delete next word
    C-k                    Cut rest of line
    M-Backspace            Delete previous word
    C-w                    Cut selection
    C-t                    Transpose characters
    C-z                    Undo
    C-Sh-z                 Redo
    C-+                    Increase font size
    C--                    Decrease font size
    Return                 Send current line to forth and insert newline
    C-Up                   Move backwards in history
    C-Down                 Move forward in history
    Alt-Up                 List previous block
    Alt-Down               List next block
    Escape                 Terminate
    Tab                    Indent or tab
    Alt-w                  Copy current selection
    Insert                 Insert unicode codepoint (hex or named character)
    F1                     Show this text
    

XIX. Dictionary layout
----------------------

The Forth dictionary is organized as a single linked list of headers,
starting with the header at the address held by the variable `dp`.

Headers have the following structure:

    Length field (1 byte): the length of the word in the lowest 5 bits (bits 0-4)
      bit 5: unused, bit 6: "smudge" bit, bit 7:; immediate bit.

    Name (0-31 bytes)

    Padding (0-3 bytes): pad link-field to address divisible by 4.

    Link (1 word): pointer to previous header.

    Code field (1 word): pointer to executable code.

    Parameter field (0-N words): data or code.


XX. Memory map
--------------

    +-----------------------+-----------+-------------------------------------+
    | Area                  |      Size | Contains                            |
    +-----------------------+-----------+-------------------------------------+
    | machine code words    |           | "text" segment                      |
    | core dictionary       |           | "data" segment                      |
    | heapspace             |       4MB | start of "bss" segment (`here`)     |
    | :                     |           |  v                                  |
    |                       |           |                                     |
    | buffer space          | 16 x 1024 | if block-words are loaded           |
    | return stack          | 256 cells | `r0` (grows upwards)                |
    | :                     |           |  v                                  |
    | parameter stack       | 2048 cells|                                     |
    | :                     |           |  ^                                  |
    | end of heap           |           | `s0` (grows downards)               |
    +-----------------------+-----------+-------------------------------------+


XXI. Register Usage
-------------------

    +----------+----------+----------+-----------+-----------+----------+----------+-----------+----------+----------------------------------+
    | Forth    | i386     | ARM      | MIPS      | Sparc     | x86_64   | m68k     | RISC-V    | PPC      | Meaning                          |
    | register | register | register | register  | register  | register | register | register  | register |                                  |
    +----------+----------+----------+-----------+-----------+----------+----------+-----------+----------+----------------------------------+
    | TOS      | eax      | r0       | $v0       | %r1       | rax      | d0       | x10 (a0)  | r3       | Top of stack                     |
    | SP       | esp      | r13      | $sp       | %g2       | rsp      | a7       | x2 (sp)   | r1       | Data-stack ptr (grows downwards) |
    | RP       | ebp      | r14      | $fp       | %g3       | rbp      | a6       | x3 (gp)   | r11      | Return-stack ptr (grows upwards) |
    | AP       | esi      | r12      | $gp       | $g4       | rsi      | a5       | x18 (s2)  | r13      | Address-pointer                  |
    | W        | edi      | r11      | $t9       | %g5       | rdi      | a4       | x19 (s3)  | r14      | "Work" register (holds CFA)      |
    |          | ebx,     | r1 - r5  | $v1,      | %l1 - %l5 | rbx,     | a0,      | x11 - x13 | r4 - r6  | Temporaries                      |
    |          | ecx,     |          | $t0 - $t1 |           | rcx,     | d1 - d2  |           |          |                                  |
    |          | edx      |          | $a0 - $a2 |           | rdx      |          |           |          |                                  |
    +----------+----------+----------+-----------+-----------+----------+----------+-----------+----------+----------------------------------+


XXII. Acknowledgements
----------------------

    Many thanks to Valery Ushakov for helping to port `ff` to NetBSD.


XXIII. License
--------------

    Copyright (c) 2015-2017, Felix L. Winkelmann
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
    3. The name of the authors may not be used to endorse or promote products
       derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


    `i386/asm.f`:

    asm-x86 is released under the mit/bsd license, in accordance
    with the preference of its original author, frank sergeant.

    
    `arm/asm.f`:
   
    this program is distributed under the terms of the 'mit license'. the text
    of this licence follows...
   
    copyright (c) 2005 j.d.medhurst (a.k.a. tixy)
   
    permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "software"), to deal
    in the software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the software, and to permit persons to whom the software is
    furnished to do so, subject to the following conditions:
   
    the above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the software.
   
    the software is provided "as is", without warranty of any kind, express or
    implied, including but not limited to the warranties of merchantability,
    fitness for a particular purpose and noninfringement.  in no event shall the
    authors or copyright holders be liable for any claim, damages or other
    liability, whether in an action of contract, tort or otherwise, arising from,
    out of or in connection with the software or the use or other dealings in
    the software.


XXIV. Contact
-------------

If you have questions, suggestions, want to report bugs or comment on
the system, please don't hesitate to contact me at 

  ` felix <at> call-with-current-continuation  <dot> org `


XXV. References
---------------

[1]: http://nasm.us/

[2]: http://www.gnu.org/software/binutils/

[3]: http://www.taygeta.com/forth/dpans.html

[4]: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#mmap_arg_struct

[5]: http://bitbucket.org/bunny351/ff

[6]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

[7]: ftp://ccreweb.org/software/kforth/examples/asm-x86.4th

[8]: http://yxit.co.uk/source/#ARM%20Assembler

[9]: http://man.cat-v.org/plan_9/6/a.out

[10]: http://christophe.lavarenne.free.fr/ff/

[11]: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html

[12]: http://www.gnu.org/software/grub/manual/html_node/index.html
