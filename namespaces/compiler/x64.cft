5
// Intel - InstructionSet-A-M-253666.pdf - section 2.1 :
// -----------------------------------------------------------------------
// instuction format ( in bytes )
// prefixes  opcode  modRm   sib        disp   immediate
//  0 - 4    1 - 3   0 - 1  0 - 1      0,1,4    0,1,4      -- number of bytes
// -----------------------------------------------------------------------
//   modRm byte ( bits )  _mod 0 : no disp ;; _mod 1 : 1 byte disp : _mod 2 : 4 byte disp ;; _mod 3 : just _reg value
//    _mod     _reg      rm
//   7 - 6   5 - 3   2 - 0 
//                   rm  4 - b100 => sib instead of ESP
// -----------------------------------------------------------------------
//  _reg/rm codes :
//  EAX 0, R9D 1, EDX 2, EBX 3, ESP 4, EBP 5, ESI 6, EDI 7
// -----------------------------------------------------------------------
//  bit positions encoding :  ...|7|6|5|4|3|2|1|0|  but nb. intel is little endian
// -----------------------------------------------------------------------
//  opCode direction bit 'd' is bit position 1 : 1 => rm/sib to _reg ; 0 => _reg to rm/sib -- for some instructions
//  sign extend bit 's' is bit position 1 for some instructions
//  operand size bit 'w' is bit position 0 for some instructions
// -----------------------------------------------------------------------
//       sib byte ( bits ) with rm 4 - b100
//    scale  index   base
//    7 - 6  5 - 3  2 - 0
//    scale 0 : [index * 1 + base]
//    scale 1 : [index * 2 + base]
//    scale 2 : [index * 4 + base]
//    scale 1 : [index * 4 + base]
// -----------------------------------------------------------------------
// intel syntax : opcode dst, src
// att syntax   : opcode src, dst

// note : x86-32 instruction format : || prefixes : 0-4 bytes | opCode : 1-3 bytes | _mod : 0 - 1 byte | sib : 0 - 1 byte | disp : 0-4 bytes | immediate : 0-4 bytes ||
// note : intex syntax  : instruction dst, src
//        att   syntax  : instruction src, dst
// note : rm : _reg memory - the _register which contains the memory address in _mod instructions

// cfrTil uses intel syntax convention

//C : sp stack pause ; 
Compiler Compiling C Asm
: :asm compileModeOn sourceCodeInit token create begin ' {| find compileWord sourceCodeOn ; immediate  
//: :asm compileModeOn sourceCodeInit token create begin ' {| find compileWord ; immediate  
: asm; semi ' {| find compileWord ; immediate
//' :asm find winfo //sp
//' asm; find winfo //sp
'compile1 '1, find alias // we can't use ',' as part of a word.name with C syntax 
'compile2 '2, find alias
'compile4 '4, find alias
'compile8 '8, find alias
: ;; ' ; find compileWord ' _prefix find compileWord ; immediate
// C : ;; ' ;; find compileWord ; immediate
//' ;; find wdiss // sp
'X64 namespace
X64
"namespaces/compiler/asmConstants.cft" include

hex
Logic Bits Combinators X64 

'x64_dbg 1 const  
'DBI 0 const
//#define x64_dbg 1
#if x64_dbg    
dscOn 
//verbosity 3 =
#endif    
: apause ; // pause ;
: sp ; //stack apause ;
sp
    
c_syntaxOn
int
CalculateModRegardingDisplacement ( _mod,  disp | rmod ) // _mod/rmod avoid name class with 'mod' function
{
    // mod reg r/m bits :
    //  00 000 000
    if ( _mod != REG )
    {
#if 1 // c_syntax/preprocessor tesing
        if ( disp == 0 ) rmod = 0 ;
        else 
        {   
            if ( disp <= 0xff ) 
                rmod = 1 ; 
            else 
            {
                rmod = 2 ; 
            }
        }
#elif 0
        //"\npreprocessor else\n" ps apause
        if ( disp == 0 ) 
        {
            rmod = 0 ;
        }
        else 
        {   
            if ( disp <= 0xff ) 
            {       
                rmod = 1 ; 
            }
            else 
            {
                //{| "\npreprocessor else\n" ps apause |}
                rmod = 2 ; 
            }
        }
#else
        if ( disp == 0 ) rmod = 0 ;
        else if ( disp <= 0xff ) rmod = 1 ; 
        else rmod = 2 ;  
#endif
    }
    else rmod = _mod ;
    return rmod ;
} prefix
//'CalculateModRegardingDisplacement find wdiss apause

Bits 
int
CalculateModRmByte ( _mod, _reg, rm, sib, disp | modRm )
{
    _mod = CalculateModRegardingDisplacement ( _mod, disp ) ;
    if ( ( _mod < 3 ) && ( rm == 4 ) ) //|| ( ( rm == 5 ) && ( disp == 0 ) ) ) )
        //if ( ( _mod < 3 ) && ( ( ( rm == 4 ) && ( sib == 0 ) ) || ( ( rm == 5 ) && ( disp == 0 ) ) ) )
    {
        // cf. InstructionSet-A-M-253666.pdf Table 2-2
        "\n\nCalculateModRmByte : MACHINE_CODE_ERROR\n\n" ps ;
        pause ;
        quit ;
    }
    if ( sib )
    {
        rm = 4 ; // from intel _mod tables
        _reg = 0 ;
    }
    //modRm = ( _mod << 6 ) + ( ( ( _reg Bits.& 0x7 ) << 3 ) + ( rm Bits.& 0x7 ) ) ; // only use 3 bits of reg/rm
    modRm = ( _mod << 6 ) + ( ( ( _reg Bits.& 0x7 ) << 3 ) + ( rm Bits.& 0x7 ) ) ; // only use 3 bits of reg/rm
    return modRm ;
} prefix

//'CalculateModRmByte find wdiss apause 
//-----------------------------------------------------------------------
//   modRm byte ( bits )  _mod 0 : no disp ; _mod 1 : 1 byte disp : _mod 2 : 4 byte disp ; _mod 3 : just reg value
//    _mod     reg      rm
//   7 - 6   5 - 3   2 - 0
//-----------------------------------------------------------------------
//  reg/rm values :
//  EAX 0, ECX 1, EDX 2, ECX 3, ESP 4, EBP 5, ESI 6, EDI 7
//-----------------------------------------------------------------------


// some checks of the internal consistency of the instruction bits

// instruction letter codes : I - immediate data ; 32 : 32 bit , 8 : 8 bit ; EAX, DSP : registers
// we could have a _mod of 0 so the modRmImmDispFlag is necessary
// operandSize : specific size of immediate data - BYTE or WORD
// SIB : scale, index, base addressing byte
#if 0
void
_Compile_ImmDispData (  immDisp,  immSize,  forceFlag )
{
    // the opcode probably is all that needs to be adjusted for this to not be necessary    
    // to not compile an imm when imm is a parameter, set isize == 0 and imm == 0
    if ( immSize > 0 )
    {
        if ( immSize == BYTE ) 
        { 
            compile1 (immDisp)  ; 
        }
        else 
        { 
            if ( immSize == 4 ) 
            { 
                compile4 (immDisp)  ; 
            }
            else 
            { 
                if ( immSize == CELL ) 
                { 
                    compile8 (immDisp)  ; 
                }
            }
        }    
    }
    else // with operandSize == 0 let the compiler use the minimal size ; nb. can't be imm == 0
    {
        if ( immDisp >= 0x100000000 ) 
        {    
            compile8 (immDisp)  ;
        }
        else 
        {
            if ( immDisp >= 0x100 ) 
            {
                compile4 (immDisp)  ;
            }
            else 
            {
                if ( immDisp || forceFlag ) 
                {
                    compile1 (immDisp)  ;
                }
            }
        }
    }
} prefix
#else
void
_Compile_ImmDispData (  immDisp,  immSize,  forceFlag )
{
    // the opcode probably is all that needs to be adjusted for this to not be necessary    
    // to not compile an imm when imm is a parameter, set isize == 0 and imm == 0
    if ( immSize > 0 )
    {
        if ( immSize == BYTE ) compile1 (immDisp)  ; 
        else 
        { 
            if ( immSize == 4 ) compile4 (immDisp)  ; 
            else if ( immSize == CELL ) compile8 (immDisp) ; 
        }    
    }
    else // with operandSize == 0 let the compiler use the minimal size ; nb. can't be imm == 0
    {
        if ( immDisp >= 0x100000000 ) compile8 (immDisp)  ;
        else 
        {
            if ( immDisp >= 0x100 ) compile4 (immDisp)  ;
            else if ( immDisp || forceFlag ) compile1 (immDisp)  ;
        }
    }
} prefix
//'_Compile_ImmDispData find wdiss pause
#endif

// Intel - InstructionSet-A-M-253666.pdf - section 2.1 :
//-----------------------------------------------------------------------
// instuction format ( number of bytes )
// prefixes  opcode  modRm   sib       disp    immediate
//  0 - 4    1 - 3   0 - 1  0 - 1    0,1,2,4    0,1,2,4      -- number of bytes
//-----------------------------------------------------------------------
//   modRm byte ( bits )  _mod 0 : no disp ; _mod 1 : 1 byte disp : _mod 2 : 4 byte disp ; _mod 3 : just reg value
//    _mod     reg      rm
//   7 - 6   5 - 3   2 -- 0 
//-----------------------------------------------------------------------
//  reg/rm values :
//  EAX 0, ECX 1, EDX 2, ECX 3, ESP 4, EBP 5, ESI 6, EDI 7
//-----------------------------------------------------------------------
//    sib byte ( bits ) :
//    scale  index   base
//    7 - 6  5 - 3  2 - 0
//-----------------------------------------------------------------------

// REX prefix ?
// controlFlags : bits ::  4      3       2     1      0         
//                       rex    imm    disp   sib    modRm      
//                      rex=16 imm=8, disp=4 sib=2  _mod/Rm=1
//                      REX_B  IMM_B  DISP_B SIB_B   MODRM_B

void
_Compile_Write_Instruction_X64 ( rex, opCode, modRm, controlFlags, sib, disp, dispSize, imm, immSize | _here )
{
#if DBI
    int nbytes ;
    _here = Here ;
#endif
    if ( rex ) compile1 ( rex ) ; 
    if ( opCode >= 0x100 ) compile2 ( opCode ) ; 
    else compile1 ( opCode ) ; 
    if ( controlFlags Bits.& MODRM_B ) compile1 ( modRm ) ;
    if ( sib && ( controlFlags Bits.& SIB_B ) ) compile1 ( sib ) ;
    if ( disp || ( controlFlags Bits.& DISP_B ) ) _Compile_ImmDispData ( disp, dispSize, 0 ) ;
    if ( imm || ( controlFlags Bits.& IMM_B ) ) _Compile_ImmDispData ( imm, immSize, ( controlFlags Bits.& IMM_B ) ) ;
#if DBI
    nbytes = Here - _here ; 
    printf ( "\n_Compile_Write_Instruction_X64 : %lx : %d bytes : ...", _here, nbytes ) ; dis ( _here, nbytes ) ; //pause () ; nl ; nl ; 
#endif
} prefix
//'_Compile_Write_Instruction_X64 find wdiss pause

int 
_CalculateRex ( _reg rm rex_w_flag | rex )
{
#if 0 
    //  0100    WRXB
    rex = 0 ;
    if ( rex_w_flag ) rex = 8 ;
    if ( _reg > 0x7 ) rex += 4 ; // (1 << 2) ;
    //if ( sib > 0x7 ) rex += 2 ; // 1 << 1 ;
    if ( rm > 0x7 ) rex += 1 ;
    if ( rex ) rex |= 0x40 ;
    return rex ;
#else // from original C code
    //rex = ( ( rex_w_flag ? 8 : 0 ) | ( ( _reg > 7 ) ? 4 : 0 ) | ( ( rm > 7 ) ? 1 : 0 ) ) ;
    rex = ( rex_w_flag ? 8 : 0 ) | ( ( _reg > 7 ) ? 4 : 0 ) | ( ( rm > 7 ) ? 1 : 0 ) ;
    if ( rex ) rex |= 0x40 ;
    return rex ;
#endif    
} prefix // prefix is not automatic with c syntax so they can be used like rpn words
//'_CalculateRex find wdiss pause


void
Compile_CalcWrite_Instruction_X64 (  rex,  opCode,  _mod,  _reg,  rm, controlFlags,  sib,  disp,  dispSize,  imm,  immSize | modRm )
{
    rex = _CalculateRex ( _reg, rm, ( immSize == 8 ) || ( controlFlags Bits.& REX_B ) ) ;
    modRm = CalculateModRmByte ( _mod, _reg, rm, sib, disp ) ;
    _Compile_Write_Instruction_X64 ( rex, opCode, modRm, controlFlags, sib, disp, dispSize, imm, immSize ) ;
} prefix
//'Compile_CalcWrite_Instruction_X64 find wdiss apause

void 
_Compile_Move ( toRegOrMem _mod _reg rm controlFlags disp | opCode ) 
{
    if ( toRegOrMem == REG ) opCode = #x8b ; 
    else opCode = #x89 ; 
    //Compile_CalcWrite_Instruction_X64 ( rex,  opCode,  _mod,  _reg,  rm, controlFlags,  sib,  disp,  dispSize,  imm,  immSize | modRm )
    Compile_CalcWrite_Instruction_X64 ( 0, opCode, _mod, _reg, rm, controlFlags, 0, disp, 0, 0, 0 ) ;
} prefix
'_Compile_Move find wdiss //pause

//                                          _Compile_Move ( toRegOrMem _mod _reg rm controlFlags disp | opCode ) 
void _Compile_Move_DataStackN_ToReg ( _reg n ) { _Compile_Move ( REG, MEM, _reg, DSP, (REX_B | MODRM_B | DISP_B), n * CELL ) ; } prefix 

// group1 : ADD OR ADC SBB AND_OPCODE SUB XOR CMP : with immediate data
void 
_Compile_Group1_Immediate ( code _mod rm disp imm immSize | opCode ) //controlFlags )
{
    // #x80 is the base opCode for this group of instructions 
    // 1000 00sw 
    opCode = #x80 ;
    //opCode = ( code << 3 ) ;
    //{ toRegOrMem == REG } { opCode |= 2 } if2

    if ( ( immSize > BYTE ) || ( imm >= 0x100 ) )
    { 
        opCode |= 1 ;
    }
    else
    { 
        if ( ( immSize <= BYTE ) || ( imm < 0x100 ) ) opCode |= 3 ; 
    }
    //Compile_CalcWrite_Instruction_X64 (  rex,  opCode,  _mod,  _reg,  rm, controlFlags,  sib,  disp,  dispSize,  imm,  immSize | modRm )
    Compile_CalcWrite_Instruction_X64 (  0,  opCode,  _mod,  code, rm, (REX_B | MODRM_B | DISP_B | IMM_B),  0,  disp,  0,  imm,  immSize ) ;
} prefix

void
_Compile_Group5 ( code, mod, rm, sib, disp, size )
{
    //Compile_CalcWrite_Instruction_X64 ( 0, 0xff, mod, code, rm, REX_B | MODRM_B | DISP_B, sib, disp, size, 0, 0 ) ;
    Compile_CalcWrite_Instruction_X64 ( 0, 0xff, mod, code, rm, (REX_B | MODRM_B | DISP_B), sib, disp, size, 0, 0 ) ;
} prefix

void
_Compile_CallThruReg ( _reg )
{
    _Compile_Group5 ( CALL, REG, _reg, 0, 0, 0 ) ;
} prefix

//                          _Compile_Group1_Immediate ( code toRegOrMem _mod rm disp imm immSize | opCode controlFlags )
void _Compile_SUBI_DSP ( imm ) { _Compile_Group1_Immediate ( SUB, REG, DSP, 0, imm, 1 ) ; } prefix

void
_Compile_Test ( _mod, _reg, rm, controlFlags, disp, imm )
{
    Compile_CalcWrite_Instruction_X64 ( 0, 0xf7, _mod, _reg, rm, REX_B | MODRM_B | controlFlags, 0, disp, 0, imm, 0 ) ; //??
} prefix

void
_Compile_Move_Reg_To_Rm ( dstRmReg, srcReg, rmRegDisp )
{
    //_Compile_Move ( toRegOrMem _mod _reg rm controlFlags disp | opCode ) 
    _Compile_Move ( MEM, MEM, srcReg, dstRmReg, (REX_B | MODRM_B | DISP_B), rmRegDisp ) ;
} prefix

void
_Compile_Move_Reg_To_StackN ( stackReg, index, _reg )
{
    _Compile_Move_Reg_To_Rm ( stackReg, _reg, index * CELL ) ;
} prefix

void
_Compile_TEST_Reg_To_Reg ( dstReg, srcReg )
{
    //_Compile_Op_Special_Reg_To_Reg ( TEST_R_TO_R, dstReg, srcReg ) ;
    Compile_CalcWrite_Instruction_X64 ( 0, 0x85, 3, srcReg, dstReg, REX_B | MODRM_B, 0, 0, 0, 0, 0 ) ;

} prefix

#define Compile_INC( mod, rm, sib, disp ) _Compile_Group5 ( INC, mod, rm, sib, disp, 0  )
#define Compile_DEC( mod, rm, sib, disp ) _Compile_Group5 ( DEC, mod, rm, sib, disp, 0  )
c_syntaxOff
infixOn
sp
: _Compile_Stack_PopToReg ( _reg ) 
    _Compile_Move_DataStackN_ToReg ( _reg @, 0 ) // 4d8b06                  mov r8, [r14]
    //"\nshould show :     4d8b06                  mov r8, [r14]" ps
    _Compile_SUBI_DSP ( CELL )                   // 4983ee08                sub r14, 0x8
    //"\nshould show :     4983ee08                sub r14, 0x8" ps
;; 
sp
//'_Compile_Stack_PopToReg find wdiss //pause
#if 0
c_syntaxOn
void
Compile_PopDspToR8AndCall ()
{
    _Compile_Stack_PopToReg ( DSP, R8 ) ;
    _Compile_CallThruReg ( R8 ) ;
}
#if 0
4d8b06                  mov r8, [r14]                                          
4983ee08                sub r14, 0x8                                           
49ffd0                  call r8                                                
c3                      ret      
#endif
c_syntaxOff
'Compile_PopDspToR8AndCall find wdiss
#endif


#if x64_dbg
//verbosity 3 =
Combinators

sp
:asm iax
    _Compile_Stack_PopToReg ( R8D )             //4d8b06                  mov r8, [r14]       
    _Compile_CallThruReg ( R8D )                //4983ee08                sub r14, 0x8
                                                //49ffd0                  call r8  
                                                //c3                      ret      
asm; 

' iax find wdiss // pause // sp 

: _Compile_Test_Imm (  _mod, rm, disp, imm )
    _Compile_Test ( _mod @, rm @, IMM_B, disp @, imm @ )
;;

: _Compile_IncDec_Reg ( op, _reg )
    //_Compile_Group5 ( op @, REG, _reg @, 0, 0, 0  )
    Compile_CalcWrite_Instruction_X64 ( 0, 0xff, REG, op @, _reg @, REX_B | MODRM_B, 0, 0, 0, 0, 0 ) 
;;

: _Compile_MoveTOS_To_R8D () _Compile_Move_DataStackN_ToReg ( R8D, 0 ) ;; // _Compile_Move ( REG, 0, EAX, DSP, 0 ) 

//                                          _Compile_Move ( toRegOrMem _mod _reg rm controlFlags disp | opCode ) 
: _Compile_ADDI_DSP ( imm ) _Compile_Group1_Immediate ( ADD, REG, DSP, 0, imm @, 1 ) ;; 

: _Compile_CMP_REG_IMM ( _reg, imm, isize ) _Compile_Group1_Immediate ( CMP, REG, _reg @, 0, imm @, isize @ ) ;; 

: Compile_Stack_Push_R8D ()
    _Compile_ADDI_DSP ( CELL ) 
    _Compile_Move_Reg_To_StackN ( DSP, 0, R8D ) 
;; 

User
: sp ; 
: qeval
    stk iax
;
' qeval find wdiss // sp

:asm stest
    _Compile_MoveTOS_To_R8D ( ) 
    _Compile_Move_DataStackN_ToReg ( R8D, 0 ) 
    Compile_Stack_Push_R8D ( ) 
    _Compile_SUBI_DSP ( CELL ) 
asm;

//' stest find wdiss pause
s
"\nthis is some purposefully funky code for testing\n" ps

#if 1 
s stest sp 
nl "x64 test" ps "ok" ' dup find xt@ iax ' ps find xt@ iax "ok" "error" assert1s sp //pause
#endif
sp
Stack
:asm ndup
    _Compile_MoveTOS_To_R8D ( )
    _Compile_SUBI_DSP ( CELL ) 
    _Compile_Move_DataStackN_ToReg ( R9D, 0 )
    "start" label 
    _Compile_TEST_Reg_To_Reg ( R8D, R8D )
    "end" 0 EQ jcc
    _Compile_ADDI_DSP ( CELL ) 
    _Compile_Move_Reg_To_StackN ( DSP, 0, R9D ) 
    _Compile_IncDec_Reg ( DEC, R8D ) 
    "start" goto
    "end" label // above jcc to Here
asm;

' ndup find wdiss sp 
7 ndup s 7 ndrop
s 
Asm
// following intel conventions in the naming : insn dst, src
// move mem to _reg 
: MOV8rm ( _reg, ptr, disp ) // 8 bit disp
    // _Compile_Move ( toRegOrMem _mod _reg rm disp ) 
    _Compile_Move ( REG, MEM, _reg @, ptr @, disp @ ) 
;;
// move mem to _reg : 32 bit offset
: MOV32rm ( _reg, ptr, disp ) // 32 bit disp
    // _Compile_Move ( toRegOrMem _mod _reg rm disp ) 
    _Compile_Move ( REG, MEM32, _reg @, ptr @, disp @ ) 
;;
: MOVmr ( ptr, disp, _reg ) 
    // _Compile_Move ( toRegOrMem _mod _reg rm disp ) 
    _Compile_Move ( MEM, MEM, _reg @, ptr @, disp @ ) 
;;
// move _reg to _reg
: MOVrr ( dstReg, srcReg )
    // _Compile_Move ( toRegOrMem _mod _reg rm disp | opCode ) 
    _Compile_Move ( REG, REG, dstReg @, srcReg @, 0 ) 
;;
#endif // x64_dbg
 
infixOff

sp 
2 + 7 assertStkChk // stack checking

    