5
// Intel - InstructionSet-A-M-253666.pdf - section 2.1 :
// -----------------------------------------------------------------------
// instuction format ( in bytes )
// prefixes  opcode  modRm   sib        disp   immediate
//  0 - 4    1 - 3   0 - 1  0 - 1      0,1,4    0,1,4      -- number of bytes
// -----------------------------------------------------------------------
//   modRm byte ( bits )  mod 0 : no disp ;; mod 1 : 1 byte disp : mod 2 : 4 byte disp ;; mod 3 : just _reg value
//    mod     _reg      rm
//   7 - 6   5 - 3   2 - 0 
//                   rm  4 - b100 => sib instead of ESP
// -----------------------------------------------------------------------
//  _reg/rm codes :
//  EAX 0, R9D 1, EDX 2, EBX 3, ESP 4, EBP 5, ESI 6, EDI 7
// -----------------------------------------------------------------------
//  bit positions encoding :  ...|7|6|5|4|3|2|1|0|  but nb. intel is little endian
// -----------------------------------------------------------------------
//  opCode direction bit 'd' is bit position 1 : 1 => rm/sib to _reg ; 0 => _reg to rm/sib -- for some instructions
//  sign extend bit 's' is bit position 1 for some instructions
//  operand size bit 'w' is bit position 0 for some instructions
// -----------------------------------------------------------------------
//       sib byte ( bits ) with rm 4 - b100
//    scale  index   base
//    7 - 6  5 - 3  2 - 0
//    scale 0 : [index * 1 + base]
//    scale 1 : [index * 2 + base]
//    scale 2 : [index * 4 + base]
//    scale 1 : [index * 4 + base]
// -----------------------------------------------------------------------
// intel syntax : opcode dst, src
// att syntax   : opcode src, dst

// note : x86-32 instruction format : || prefixes : 0-4 bytes | opCode : 1-3 bytes | mod : 0 - 1 byte | sib : 0 - 1 byte | disp : 0-4 bytes | immediate : 0-4 bytes ||
// note : intex syntax  : instruction dst, src
//        att   syntax  : instruction src, dst
// note : rm : _reg memory - the _register which contains the memory address in mod instructions

// cfrTil uses intel syntax convention

//C : sp stack pause ; 
Compiler Compiling C Asm
: :asm compileModeOn sourceCodeInit token create begin ' {| find compileWord sourceCodeOn ; immediate  
//: :asm compileModeOn sourceCodeInit token create begin ' {| find compileWord ; immediate  
: asm; ' |} find compileWord semi ; immediate
' :asm find winfo //sp
' asm; find winfo //sp
'compile1 '1, find alias
'compile2 '2, find alias
'compile4 '4, find alias
'compile8 '8, find alias
 
: ;; ' ; find compileWord ' _prefix find compileWord ; immediate
// C : ;; ' ;; find compileWord ; immediate
' ;; find wdiss // sp
'IA32 namespace
IA32
"namespaces/compiler/asmConstants.cft" include
hex
Logic Bits Combinators IA32 
dscOn //verbosity 3 =
: apause ; //pause ;

#if 1
c_syntaxOn
int
CalculateModRegardingDisplacement ( int8 mod, int32 disp )
{
    // mod reg r/m bits :
    //  00 000 000
    if ( mod != REG )
    {
#if 0
        if ( disp == 0 ) 
            mod = 0 ;
        else 
        {   
            if ( disp <= 0xff ) 
                mod = 1 ; 
            else 
            {
                mod = 2 ; 
            }
        }
#elif 0
        //"\npreprocessor else\n" ps apause
        if ( disp == 0 ) 
        {
            mod = 0 ;
        }
        else 
        {   
            if ( disp <= 0xff ) 
            {       
                mod = 1 ; 
            }
            else 
            {
                //{| "\npreprocessor else\n" ps apause |}
                mod = 2 ; 
            }
        }
#else
        if ( disp == 0 ) mod = 0 ;
        else if ( disp <= 0xff ) mod = 1 ; 
        else mod = 2 ; 
#endif
    }
    return mod ;
} prefix
'CalculateModRegardingDisplacement find wdiss apause

int
CalculateModRmByte ( int64 mod, int _reg, int rm, int sib, int64 disp )
{
    int modRm ;
    mod = CalculateModRegardingDisplacement ( mod, disp ) ;
    if ( ( mod < 3 ) && ( rm == 4 ) ) //|| ( ( rm == 5 ) && ( disp == 0 ) ) ) )
        //if ( ( mod < 3 ) && ( ( ( rm == 4 ) && ( sib == 0 ) ) || ( ( rm == 5 ) && ( disp == 0 ) ) ) )
    {
        // cf. InstructionSet-A-M-253666.pdf Table 2-2
        //d: CfrTil_Exception (MACHINE_CODE_ERROR, 0, 1 ) ;
        quit ;
    }
    if ( sib )
    {
        rm = 4 ; // from intel mod tables
        _reg = 0 ;
    }
    modRm = ( mod << 6 ) + ( ( _reg Bits.& 0x7 ) << 3 ) + ( rm Bits.& 0x7 ) ; // only use 3 bits of reg/rm
    //modRm = ( mod << 6 ) + ( ( _reg ) << 3 ) + ( rm ) ; // only use 3 bits of reg/rm
    return modRm ;
} prefix
'CalculateModRmByte find wdiss //apause
//-----------------------------------------------------------------------
//   modRm byte ( bits )  mod 0 : no disp ; mod 1 : 1 byte disp : mod 2 : 4 byte disp ; mod 3 : just reg value
//    mod     reg      rm
//   7 - 6   5 - 3   2 - 0
//-----------------------------------------------------------------------
//  reg/rm values :
//  EAX 0, ECX 1, EDX 2, ECX 3, ESP 4, EBP 5, ESI 6, EDI 7
//-----------------------------------------------------------------------


// some checks of the internal consistency of the instruction bits

// instruction letter codes : I - immediate data ; 32 : 32 bit , 8 : 8 bit ; EAX, DSP : registers
// we could have a mod of 0 so the modRmImmDispFlag is necessary
// operandSize : specific size of immediate data - BYTE or WORD
// SIB : scale, index, base addressing byte
void
_Compile_ImmDispData ( int64 immDisp, int64 immSize, int forceFlag )
{
    // the opcode probably is all that needs to be adjusted for this to not be necessary    
    // to not compile an imm when imm is a parameter, set isize == 0 and imm == 0
    if ( immSize > 0 )
    {
        if ( immSize == BYTE ) 
        { 
            compile1 (immDisp)  ; 
        }
        else 
        { 
            if ( immSize == 4 ) 
            { 
                compile4 (immDisp)  ; 
            }
            else 
            { 
                if ( immSize == CELL ) 
                { 
                    compile8 (immDisp)  ; 
                }
            }
        }    
    }
    else // with operandSize == 0 let the compiler use the minimal size ; nb. can't be imm == 0
    {
        if ( immDisp >= 0x100000000 ) 
        {    
            compile8 (immDisp)  ;
        }
        else 
        {
            if ( immDisp >= 0x100 ) 
            {
                compile4 (immDisp)  ;
            }
            else 
            {
                if ( immDisp || forceFlag ) 
                {
                    compile1 (immDisp)  ;
                }
            }
        }
    }
} prefix
'_Compile_ImmDispData find wdiss //apause

// Intel - InstructionSet-A-M-253666.pdf - section 2.1 :
//-----------------------------------------------------------------------
// instuction format ( number of bytes )
// prefixes  opcode  modRm   sib       disp    immediate
//  0 - 4    1 - 3   0 - 1  0 - 1    0,1,2,4    0,1,2,4      -- number of bytes
//-----------------------------------------------------------------------
//   modRm byte ( bits )  mod 0 : no disp ; mod 1 : 1 byte disp : mod 2 : 4 byte disp ; mod 3 : just reg value
//    mod     reg      rm
//   7 - 6   5 - 3   2 -- 0 
//-----------------------------------------------------------------------
//  reg/rm values :
//  EAX 0, ECX 1, EDX 2, ECX 3, ESP 4, EBP 5, ESI 6, EDI 7
//-----------------------------------------------------------------------
//    sib byte ( bits ) :
//    scale  index   base
//    7 - 6  5 - 3  2 - 0
//-----------------------------------------------------------------------

// REX prefix ?
// controlFlags : bits ::  4      3       2     1      0         
//                       rex    imm    disp   sib    modRm      
//                      rex=16 imm=8, disp=4 sib=2  mod/Rm=1
//                      REX_B  IMM_B  DISP_B SIB_B   MODRM_B

void
_Compile_Write_Instruction_X64 ( rex, opCode, modRm, controlFlags, sib, disp, dispSize, imm, immSize )
{
    if ( rex ) { compile1 ( rex ) ; }
    if ( opCode > 0xff ) { compile2 ( opCode ) ; }
    else { compile1 ( opCode ) ; }
    if ( controlFlags Bits.& MODRM_B ) compile1 ( modRm ) ;
    if ( sib && ( controlFlags Bits.& SIB_B ) ) compile1 ( sib ) ;
    if ( disp || ( controlFlags Bits.& DISP_B ) ) _Compile_ImmDispData ( disp, dispSize, 0 ) ;
    if ( imm || ( controlFlags Bits.& IMM_B ) ) _Compile_ImmDispData ( imm, immSize, ( controlFlags Bits.& IMM_B ) ) ;
} prefix
'_Compile_Write_Instruction_X64 find wdiss apause

int 
_CalculateRex ( _reg rm sib operandSize )
{
    //  0100    WRXB
    int rex = 8 ;
    if (( operandSize == 8 ) || (_reg > 0x7 ) || ( rm > 0x7 ) )
    {
        //rex = 8 ; // 1 << 3 ;
        //byte rex = 0x48 ;
        if ( _reg > 0x7 ) rex += 4 ; // (1 << 2) ;
        if ( sib > 0x7 ) rex += 2 ; // 1 << 1 ;
        if ( rm > 0x7 ) rex += 1 ;
        if ( rex ) rex |= 0x40 ;
    }
    return rex ;
} prefix // prefix is not automatic with c syntax so they can be used like rpn words
'_CalculateRex find wdiss apause

void
Compile_CalcWrite_Instruction_X64 ( int rex, int opCode, int mod, int _reg, int rm, int16 controlFlags, int sib, int64 disp, int dispSize, int64 imm, int immSize | modRm )
{
    <dbg> rex = Calculate_Rex ( _reg, rm, ( immSize == 8 ) || ( controlFlags Bits.& REX_B ) ) ;
    modRm = CalculateModRmByte ( mod, _reg, rm, sib, disp ) ;
    _Compile_Write_Instruction_X64 ( rex, opCode, modRm, controlFlags, sib, disp, dispSize, imm, immSize ) ;
} prefix
'Compile_CalcWrite_Instruction_X64 find wdiss
c_syntaxOff 
#endif
infixOn // c_syntaxOff turns off infix

// no sib yet -- sib has not been needed here yet !
: _Compile_InstructionX64 ( opCode modFlag mod _reg rm disp imm isize | rex _here )
    _here = here
    rex = _CalculateRex ( _reg rm 0 isize ) 
    Compile_CalcWrite_Instruction_X64 ( rex @, opCode @, mod @, _reg @, rm @, 0, 0, disp @, 8, 0, 0 )
#if 0
    { rex @ } { rex @ 1, } if2
    _Compile_OpCode ( opCode @ ) 
    { modFlag @ } { _Compile_ModRmDisp ( mod @, _reg @, rm @, disp @ ) } if
    { ( imm @ ) || ( isize @ ) } { _Compile_Imm ( imm @, isize @ ) } if
#endif
    nl _here @ (here - (_here @)) dup p " : " ps dis
;;
'_Compile_InstructionX64 find wdiss sp

: _Compile_ModRm ( mod _reg rm ) ( ( mod @ << 6 ) | ( ( _reg @ Bits.& 7 ) << 3 ) | ( rm @ Bits.& 7 ) ) 1,  ;; 
//' _Compile_ModRm find wdiss sp

: _Compile_Imm ( imm isize )
    { isize @ == 1 } { imm @ 1, } if 
    { isize @ == 4 } { imm @ 4, } if 
;;

: _Compile_OpCode ( opCode ) 
    { opCode @ > 255 } { opCode @ 2, } { opCode @ 1, } ifElse
;; 

: _Compile_ModRmDisp ( mod _reg rm disp )
    { mod @ != REG } 
    { 
        { disp @ == 0 } { mod = 0 } 
        {
            { disp <= #Xff } { mod = MEM8 } { mod = MEM32 } ifElse
        }
        ifElse
    }
    if
    _Compile_ModRm (  mod @, _reg @, rm @ )
    { mod @ == 1 } { disp @ 1, } if
    { mod @ == 2 } { disp @ 4, } if
;; 

: _Compile_X86_OpModRegRmDisp ( opCode mod _reg rm disp )
    _Compile_InstructionX64 ( opCode @, 1, mod @, _reg @, rm @, disp @, 0, 0 ) 
;;

: _Compile_X86_OpModRegRm ( opCode mod _reg rm )
    _Compile_InstructionX64 ( opCode @, 1, mod @, _reg @, rm @, 0, 0, 0 ) 
;;

: _Compile_Test (  mod, _reg, rm, disp, imm )
 // _Compile_InstructionX64 ( opCode modFlag mod _reg rm disp imm isize )
    _Compile_InstructionX64 ( #xf7, 1, mod @, _reg @, rm @, disp @, imm @, CELL ) 
;;

: _Compile_Test_Imm (  mod, rm, disp, imm )
    _Compile_Test (  mod @, 0, rm @, disp @, imm @ )
;;

: _Compile_IncDec_Reg ( op, _reg )
    op += ( _reg @ )  
    // op ( _reg @ ) += // TODO : research : why doesn't this work 
    op @ 1, 
;;
: _Compile_Move ( toRegOrMem mod _reg rm disp | opCode ) 
    //<dbg> { toRegOrMem @ == REG } { opCode = #x8b } { opCode = #x89 } ifElse
    { toRegOrMem @ == REG } { opCode = #x8b } { opCode = #x89 } ifElse
    //_Compile_X86_OpModRegRmDisp ( opCode @, mod @, _reg @, rm @, disp @ ) // for improved testing, better is below ...
    _Compile_InstructionX64 ( opCode @, 1 mod @, _reg @, rm @, disp @, 0, 0 ) 
;;

: _Compile_Move_DataStackN_ToReg ( _reg n ) _Compile_Move ( REG, 0, _reg @, DSP, n @ * CELL ) apause ;; 
: _Compile_MoveTOS_To_R8D () _Compile_Move_DataStackN_ToReg ( R8D, 0 ) ;; // _Compile_Move ( REG, 0, EAX, DSP, 0 ) 

: _Compile_Move_Reg_ToDataStackN ( n _reg ) _Compile_Move ( MEM, 1, _reg @, DSP, n @ * CELL ) ;; 

// group1 : ADD OR ADC SBB AND_OPCODE SUB XOR CMP : with immediate data
: _Compile_Group1_Immediate ( code mod rm disp imm iSize | opCode )
    // #x80 is the base opCode for this group of instructions 
    // 1000 00sw 
    opCode = #x80
    { ( iSize @ > BYTE ) || ( imm @ > #xff ) } 
    { 
        opCode |= 1
        // iSize = CELL
    }
    { 
        { ( iSize @ <= BYTE ) || ( imm @ < #x100 ) } { opCode |= 3 } if
    }
    ifElse
    // we need to be able to set the size so we can know how big the instruction will be in eg. CompileVariable
    // otherwise it could be optimally deduced but let caller control by keeping operandSize parameter
    // some times we need cell_t even though a byte would work
    _Compile_InstructionX64 ( opCode @, 1, mod @, code @, rm @, disp @, imm @, iSize @ ) 
;;
// ' _Compile_Group1_Immediate find wdiss sp

: _Compile_CALL_EAX _Compile_X86_OpModRegRm ( #xff, 3, 2, 0 ) ;; 

: _Compile_CALL_Reg ( _reg ) _Compile_X86_OpModRegRm ( #xff, 3, 2, _reg @ ) ;; 

: _Compile_ADDI_DSP ( imm ) _Compile_Group1_Immediate ( ADD, REG, DSP, 0, imm @, 1 ) ;; 

: _Compile_SUBI_DSP ( imm ) _Compile_Group1_Immediate ( SUB, REG, DSP, 0, imm @, 1 ) ;; 

: _Compile_CMP_REG_IMM ( _reg, imm, isize ) _Compile_Group1_Immediate ( CMP, REG, _reg @, 0, imm @, isize @ ) ;; 

: Compile_Stack_Push_R8D ()
    _Compile_ADDI_DSP ( CELL ) 
    _Compile_Move_Reg_ToDataStackN ( 0, R8D ) 
;; 

: Compile_Stack_Pop_R8D ()
    _Compile_Move_DataStackN_ToReg ( R8D, 0 ) 
    _Compile_SUBI_DSP ( CELL ) 
;; 

#if 1
Combinators
:asm iax
    d: Compile_Stack_Pop_R8D ( ) 
    _Compile_CALL_Reg ( R8D ) 
asm; 

' iax find wdiss //sp 
User
: qeval
    stk iax
;
' qeval find wdiss // sp

:asm stest
    _Compile_MoveTOS_To_R8D ( ) 
    _Compile_Move_DataStackN_ToReg ( R8D, 0 ) 
    Compile_Stack_Push_R8D ( ) 
    _Compile_SUBI_DSP ( CELL ) 
asm;

' stest find wdiss // sp 
s
"\nthis is some purposefully funky code for testing\n" ps

#if 0 //dbOn @ not
s stest s //sp
s
nl "ia32 test" ps "ok" dup ' ps find xt@ qeval "ok" "error" assert1s 
#endif

Stack
:asm ndup
    _Compile_MoveTOS_To_R8D ( )
    _Compile_SUBI_DSP ( CELL ) 
    _Compile_Move_DataStackN_ToReg ( R9D, 0 )
    "start" label 
    _Compile_Test_Imm ( REG, R8D, 0, -1 )
    // _Compile_Test ( REG, 0, R9D, 0, -1 )
    // _Compile_CMP_REG_IMM ( R8D, 0, CELL )  
    "end" 0 EQ jcc
    _Compile_ADDI_DSP ( CELL ) 
    _Compile_Move_Reg_ToDataStackN ( 0, R9D ) 
    _Compile_IncDec_Reg ( DEC, R8D ) 
    "start" goto
    "end" label // above jcc to Here
asm;

' ndup find wdiss // sp

Asm
// following intel conventions in the naming : insn dst, src
// move mem to _reg 
: MOVrm ( _reg, ptr, disp ) // 8 bit disp
    // _Compile_Move ( toRegOrMem mod _reg rm disp ) 
    _Compile_Move ( REG, MEM, _reg @, ptr @, disp @ ) 
;;
// move mem to _reg : 32 bit offset
: MOVLrm ( _reg, ptr, disp ) // 32 bit disp
    // _Compile_Move ( toRegOrMem mod _reg rm disp ) 
    _Compile_Move ( REG, MEM32, _reg @, ptr @, disp @ ) 
;;
: MOVmr ( ptr, disp, _reg ) 
    // _Compile_Move ( toRegOrMem mod _reg rm disp ) 
    _Compile_Move ( MEM, MEM, _reg @, ptr @, disp @ ) 
;;
// move _reg to _reg
: MOVrr ( dstReg, srcReg )
    // _Compile_Move ( toRegOrMem mod _reg rm disp | opCode ) 
    _Compile_Move ( REG, REG, dstReg @, srcReg @, 0 ) 
;;
#endif
 
infixOff
//apause
2 + 7 assertStkChk // stack checking
