5 // stack checking marker
: sp ; //stack pause ; 
//verbosity 0 = 
// logOn
verbosity 1 = 
Debug
: d: _dbgOn dbgSourceCodeOn ; immediate debugWord // a debugWord has special behavior : doesn't interfere with optimization
"OptimizeOn" variable
OptimizeOn 1 = 
#if OptimizeOn @
optimizeOn inlineOn
#else
optimizeOff inlineOff
#endif
Root 
: ' _tick ; immediate
: find _find ; immediate
//_dbgOn 'tick ' _tick find alias immediate
'tick ' _tick find alias immediate
'ndrop '_ndrop find alias immediate 

"log" variable 
"User" namespace 
Io
: _ps printString ; inline
: ps space _ps ;
: prints _ps ;
: pn intPrint ;
: _p intPrint ;
: p space intPrint ;
'_hp 'hexIntPrint find alias
: hp space _hp ;
: print space intPrint ;
"nl" ' newline find alias keyword
: _logWrite "cfrTil.log" logWrite ;
: _logAppend "cfrTil.log" logAppend ;

// aliases 
Debug
//"dbg" '_dbg find alias immediate debugWord
"dbrk" ' <dbg> find alias debugWord
"locals" 'localsShow find alias
"regs" 'cpuStateShow find alias
'nt 'namespaceTreeWithWords find alias
'dscOn 'dbgSourceCodeOn find alias
'dscOff 'dbgSourceCodeOff find alias
'scOn 'dscOn find alias
'scOff 'dscOff find alias
: v4 verbosity 4 = ;
: v1 verbosity 1 = ;

User
"const" ' constant find alias
"_const" ' _constant find alias
"var" ' variable find alias
"_var" ' _variable find alias
"wdis" ' wordDisassemble find alias
's 'stack find alias
: p space intPrint ;
'dbgOnVar var 
'dbOn 'dbgOnVar find alias
: dbgOn dbgOnVar 1 = ;
: dbgOff dbgOnVar 0 = ;
: Is_DebugOn dbgOnVar @ ;
dbgOff
User
#if Is_DebugOn
: mp mem pause ;
: sp stack pause ;
#else
: mp ; //mem pause ;
: sp ; //stack pause ;
#endif
mp

Combinators
"ix" ' call find alias immediate
"qEval" ' call find alias immediate
"ifte" ' tf3 find alias
"ifElse" ' tf3 find alias

User
#if 1
: _SMN_ "StartupMacros" ;                           // _SMN_ : string startup macros namespace 
"StartupMacros" namespace                           // create a namespace for string macros to be used 
StartupMacros                                       // switch to that namespace
: Delimiters "/" ;                                  // set delimiters to be used with string macros
// "_startDirectory_" variable                      // created and set in CfrTil_ResetAll_Init
: namespaces _startDirectory_ @ ;                   // this line also works in place of the next line
                                                    // '_startDirectory_' is a variable created in the function 
                                                    // CfrTil_ResetAll_Init in the file init.c
//: namespaces "/usr/local/lib/cfrTil64/namespaces" ; // our currently only ?!overloaded!? string macro allowing 
                                                    // us to parameterize the startup; can be properly started 
                                                    // in any directory now if it is installed with 'make install' 
                                                    // in "/usr/local/lib/cfrTil"
// stringMacrosOn                                   // turn on the macros; doesn't work if not initialized like eg. above initialization
                                                    // nb. we don't turn it on here until about line 304
// stringMacrosOff                                  // turn off the macros
#endif
Lexer User 

// nb. there is still some (alot of) old junk here and especially in the test files and some of the comments may not apply anymore ...
// echoOn
// verbosity 1 = 
//autoVarOn
Debug
"DebugFlag" variable
DebugFlag 0 =

Compiler 
// nb :: .'"[] :: these five characters - dot, tick, quote left bracket, right bracket - .'"[] - are character macros including the brackets they work at the char level in readline
// set up some traditional Forth words from internal primitives
// core internal c defined words : begin _end token _tick _immediate definition compile constant variable alias compileModeOn wordInit wordAdd wordFinish
//quote ' quote quote find alias _immediate
"'" quote quote find alias _immediate
"immediate" ' _immediate find alias _immediate
"compileWord" ' _compileWord find alias immediate
"compileCall" ' _compileCall find alias immediate
"swap" ' _swap find alias immediate
Interpreter 
"{" ' begin find alias immediate keyword
"end" ' _end find alias immediate
"}" ' end find alias keyword
"xt@" { xt @ } word immediate // ' definition alias immediate
"_semi" create { xt= wordFinish } xt= wordFinish 
"semi" create { _end _semi } _semi 
";" ' semi find alias immediate syntactic
: word swap create swap _semi ;  //'word wordDisassemble pause
//: word ( name block ) name @ create block @ _semi ;  // works but it is 10 bytes more code
//'word find wdis //pause
":" { compileModeOn sourceCodeInit token create begin } word // immediate // begin is not an immediate word

Class
'_new 'new find alias prefix
C
: ;; semi _prefix ; immediate syntactic
c_syntaxOn //using
type int8 ; int8.size = 1 ;
type int16 ; int16.size = 2 ;
type int32 ; int32.size = 4 ;
type int64 ; int64.size = 8 ;
type void ; void.size = 0 ;
type char ; char.size = 1 ;
type word ; word.size = 2 ;
type int ; int.size = 8 ;
type long ; long.size = 8 ;
type quad ; quad.size = 16 ;
c_syntaxOff
BigNum
: fprint space _fprint ;
: eprint space _eprint ;
// pWidth : "Minimum number of characters to be printed. If the value to be printed is shorter than this number, 
// the result is padded with blank spaces. The value is not truncated even if the result is larger."
// pPrecision : this is the number of digits to be printed after the decimal point" 
: bnInit ( precision width ) precision @ pPrecision width @ pWidth ;; 
//'bnInit find wdis
'p 'fprint find alias
bnInit ( 16 16 )
Root
: bigNumOff "BigNum" notUsing ;
'bnoff 'bigNumOff find alias
: bnon BigNum bnInit ( 16 16 ) ;
//d: bnon
bnoff

Compiler 
: var: { token dup ";" strcmp } { _var } while drop ; immediate // nb : no quotation marks around variable names with var: ... ;
var: DebugFlag classTestRead streamLine doInit1 doDemo doTest doLisp COMBINATOR_TOOKIT doLisp testing testLisp x Zenfone2 ; // _TestDone_ ; 
: nstrcat: "" { token dup ";" strcmp } { strcat " " strcat } while drop ; immediate // nb : no quotation marks around names
"mod" 'modulo find alias
// "Preprocessor" class
//Lisp
//"lambda" "_lambda" find alias // nb! : can't use C/Compiler/Forth ' (tick) in Lisp namespace - it has another meaning there! : this construction also has same meaning

Namespace
: using: { token dup ";" strcmp } { usingFirst } while drop ; // eg - "using: User Lisp ;"
: notUsing: { token dup ";" strcmp } { notUsing } while drop ; 
: usingLast: { token dup ";" strcmp } { usingLast } while drop ; 
notUsing: C_Combinators C_Syntax Lisp ;
sp
System
"Black" 0 const
"Red" 1 const
"Green" 2 const
"Yellow" 3 const
"Blue" 4 const
"Magenta" 5 const
"Cyan" 6 const
"White" 7 const
"Default" 9 const
//: netbeans Blue Default setDebugColors ; : nnb Blue Black setDebugColors ; // netbeans // nnb

Root
"fr" 'fullRestart find alias
"ri" 'restartInit find alias
//'q 'quit find alias
System
"true" 1 const
"false" 0 const
"T" 1 const
"F" 0 const

Debug
// make immediate/word immediate - compile time versions of some words
//: d: _dbgOn ; immediate debugWord // a debugWord has special behavior : doesn't interfere with optimization
: _s stack ; 
: s stack ; immediate
: sinit stackInit ; 
: dcm decimal ; immediate // a non hex interpreted word
//: iun using stack namespaceTree ; immediate
: slp "stack at " ps location stack _pause ;
C
: logWrite ( str ) _logWrite nl str @ ps nl ;
: logAppend ( str ) _logAppend nl str @ ps nl ;

Word 
: code definition ;

C
System
//dscOn //verbosity 3 =
: location filename ps space decimal lineNumber _p "." _ps charNumber _p ;
: pdl  "-----------------------------" ps ;
: pel  "=============================" ps ;
: _source ( addToHistoryFlag  pword )
    { addToHistoryFlag @ } { pword @ sourceAdd } { pword @ sourceDontAdd } ifElse 
;;
: _wdiss ( addToHistoryFlag pword ) 
    nl pel 
    _source ( addToHistoryFlag @ pword @ ) nl pdl 
    pword @ wdis 
    { pword @ } 
    { nl "Word :" _ps hex pword p ":: Compiled at :" ps pword @ definition p decimal } if
    nl pel decimal 
    nl "::> 'wdiss' was called at" _ps location "<::" ps nl
;;
//scOff
//: wdiss ( pword ) _wdiss ( 1 pword @ ) ; //debugWord    // add wdiss words to history list
: wdiss ( pword ) _wdiss ( 0 pword @ ) ; //debugWord      // don't add wdiss words to history list
: wdissl ( pword ) logOn _wdiss ( 0 pword @ ) logOff ; //debugWord      // don't add wdiss words to history list
"winfo" ' wdiss find alias
//' wdiss find _wdiss
: sys mem namespaces words stack using in ; 
'aw 'allWords find alias
: stk stack ; //debugWord 
: ti timerInit ;
: ahalt stop ;
: vb ( n ) verbosity n @ = ; : vb3 3 vb ; : vb2 2 vb ; : vb1 1 vb ; : vb0 0 vb ;
: sOff vb1 inlineOff optimizeOff ;
: sOn vb3 inlineOn optimizeOn ;
"ahOn" ' addToHistoryOn find alias
"ahOff" ' addToHistoryOff find alias
: adps ( s ) alertColors s @ ps defaultColors ;
: ddps ( s ) debugColors s @ ps defaultColors ;
//dbgOnVar 1 = 
#if Is_DebugOn
dscOn //verbosity 3 =
#endif
: _assert0 ( n m ) { n @ m @ != } { nl location hex n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { } ifElse ; //{ " ok" ps nl } ifElse ; // no "ok" with this word
: _assert ( n m ) nl  nl "_assert ::" ps { n @ m @ != } { n @ p "!=" ps m @ p "<:" ps "Error!" adps _info _pause } { " ok" ps nl } ifElse ;
: _assert1 ( n m str ) { n @ m @ != } { str @ ps "error" ps _info _pause } if ;
: assert1 ( n m str ) { n @ m @ != } { nl str @ ps ":> got : " ps n @ p "!=" ps m @ p " : expected <:" ps "Error!" adps _info _pause } { str @ ps "ok\n" ps } ifElse ;
: assert1s ( s1 s2 str ) { s1 @ s2 @ strcmp } { nl str @ ps "error" ps _info _pause } if ;
: _assert2 ( n m str ) { n @ m @ == } { str @ ps "ok" ps nl } { str @ ps "error" ps _info _pause } ifElse ; 
: assert2 ( n m str ) { n @ m @ == } { nl str @ ps "ok" ps nl } { nl str @ ps "error" ps _info _pause } ifElse ;
: assert0 ( n m ) { n @ m @ != } { nl "error" ps _info _pause } if ; 
"assert" ' assert1 find alias
: _assertStkChk ( n m | str )  
    { verbosity @ 1 > }
    {
        { DebugFlag @ } 
        { 
            debugColors
            str "\n assertStkChk ::" = 
            { n @ m @ == }
            { nl location ":" ps str @ ps "ok" ps nl sp } 
            { tab nl location ":" ps str @ ps alertColors "\n Error!\n" ps n @ p "!=" ps m @ p sp nl quit } 
            ifElse 
            defaultColors 
        } 
        { nl sp n @ m @ "assertStkChk" assert }
        ifElse
    } if2 
; 
: assertStkChk _assertStkChk ; //"\n_assertStkChk : " ps stack pause ; 
scOff
//' _assertStkChk find wdiss //pause
: TODO ( str ) nl nl pdl nl str @ adps location nl pdl nl nl { dbgOnVar @ } { sp } if2 ;; //pause ;;
Root
User 
: pause nl _pause ;
: opOff optimizeOff inlineOff state ;
: opOn1 optimizeOn inlineOn { verbosity @ 1 > } { state } if ;
: vck ( n w ) { verbosity @ n @ != } { verbosity n @ = w @ _find wordRun } if2 ;
'vck find wdiss //pause
: opOn ( n )
    optimizeOn inlineOn 
#if 1
    n @ ' state literal vck  // literal pops the stack and turns 'state into a string
#elif 1 // same functionally
    n @  "state" vck  // literal turns 'state into a string
#elif 0 // doesn't work
    n @ 'state vck  // literal turns 'state into a string
#endif
    //pause
;
' opOn find winfo //pause
//2 opOn 1 opOn 

"s" ' stack find alias
// : s stack location pause ;
// : s stack dbg ;
"istring" ' interpretString find alias 
"def" ' word find alias 
Compiler
">;" ' >? find alias

Root C
"allot" ' allocateMem find alias
// : include location s include location s pause ;
// : include location nl include ;

: include1 _dup debugColors "\n'include'" ps ps " :: at :" ps location nl defaultColors sp include  ;
Debug
#if ( DebugFlag @ )
: s stack alertColors location defaultColors ;
// : s stack alertColors location defaultColors ;
// : include 1 timerInit info stack include stack 1 time ; 
// : include include stack ;
// : include ( f ) vb3 alertColors decimal nl location nl "Entering : " ps f @ ps nl s f @ include defaultColors ;
: include include1 debugColors "location :" ps location nl defaultColors ;
vb3
#endif
Interpreter
'_defined '_find find alias 
' defined '_find find alias immediate 
C Compiler Int Lexer
: ofile ( name | file input result )
    input 0 =
    "open/read/print :: " ps name @ ps nl
    file name @ fopen =
    nl { result file @ input 1 fread = input @ emit } { result @ 1 == } doWhile 
    file @ fclose
; prefix
'ofile find wdiss
Root
: license ofile ( "./LICENSE" ) ;
license //pause
OpenVmTil
: lispOff "Lisp" notUsing ; //lcReset ;

c_syntaxOff
scOff

sp 
: sh _sh ; prefix
stringMacrosOn
//: testCfrTil "namespaces/init.cft" <dbg> include ;
: testCfrTil "namespaces/init.cft" include ;
#if 1 //! testPreviousVersion 
'ctloc 'compileTimeLocation find alias debugWord
: spl { compileMode } { locationPush compileThisWord } { locationPrint _s _pause } ifElse ; immediate // nb! can only be used withing compiled words not interpreted
#else
: ctloc ;
#endif

Root 
'doX64 1 const
'doScript 1 const
'_doDemo 0 const    
dbgOff
//dbgOn 
#if Is_DebugOn 
System 
testCfrTil // dT0 //demo //dT0
#if _doDemo 
demo 
#endif //dT0
stringMacrosOff

#else
// you can trim this file to your needs and put your personal init code here maybe

#if 0
Lisp

( define j ( lambda ( a b c ) ( + a b c)))
(define h ( lambda (a b c) (a c b) ) ) 
( define h ( lambda ( a b c ) ( + a b c)))
( define k ( lambda ( a b ) ( + a b )))
(define g ( lambda (a b c) (a b c) ) )

( k ( j 1 2 3 ) ( h 2 3 66 ) ) sp // 77 ...
( + ( k ( j 1 2 3 ) ( h 2 3 66 ) ) ( + 698 2 ) ) // 777
( + ( k ( j 1 2 3 ) ( h 2 3 59 ) ) 7 ) // 77
( g + ( k ( j 1 2 ( h 2 3 ( k 59 4 ) ) ) 6 ) 0 ) // 77
( - ( + 1 2 ( * 3 4 ) ( / 4 2 ) ( - 9 8 ) 10 770 787 34 ) 21 787 34 )  // == 777

lispOff
#endif

#endif
2 + 7  assertStkChk // stack checking