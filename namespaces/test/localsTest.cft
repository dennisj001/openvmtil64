
5
#if 1 //_TestDone_ @ not // prevent including twice
decimal
User
 : hi ( a b ) a @ b @ + p ; : hey ( a b ) a @ b @ hi a @ b @ hi a @ b @ hi ; 1 2 hey       
C
// demonstrate calling order of local variables
dscOn //verbosity 3 =
: hi ( m x | n -- n ) n m @ = n @ p ; : hey ( m x | n -- n ) n m @ = n @ 1 hi p n @ 1 hi p n @ 1 hi p ; 
: heey ( m x | n -- n ) n m @ = n @ 1 hey p n @ 1 hey p n @ 1 hey p ; 
7 1 heey dup p 7 _assert verbosity 1 = //pause
dscOff
: a123 ( one two three )

    one @ p
    two @ p
    three @ p
;
1 2 3 a123 nl
: a1234 ( one two three four )

    one @ p
    two @ p
    three @ p
    four @ p
;;
a1234 ( 1 2 3 4 )
sp
dscOn
// nb. this is some of the oldest testing
: hey ( n m | o q )
	//nl "startHey" prints
	o m @ = 	m @ o @ "hey_1_assert" assert
	q n @ =  	n @ q @ "hey_2_assert" assert
	n @ m @ o @ q @ + + + 1 + dup p 7 "hey_3_assert" assert
	n @ m @ + o @ + q @ + 1 + dup p 7 "hey_4_assert" assert
        //" after hey" ps 
;
' hey find wdiss 
1 2 hey sp 
: hey1 ( a b ) a @ b @ hey ; 
1 2 hey1 sp
: hey2 ( n m | o q ) 
 	//nl "startHey2" prints
	m @ o store     m @ o @ _assert
	n @ q store     n @ q @ _assert
        n @ m @ hey1 
	n @ m @ + o @ + q @ + 1 + dup p 7 _assert
        //" afterHey2" prints
;
1 2 hey2 sp

nl "beforeHeey" prints nl

: heey ( a b ) a @ b @ hey2 a @ b @ hey2 ;
: heey2 ( a b ) a @ b @ heey a @ b @ heey ;
: heeey2 ( a b ) a @ b @ heey2 a @ b @ heey2 ;
: heeeey2 ( a b ) a @ b @ heeey2 a @ b @ heeey2 ;
1 2 heey 
1 2 heey2 
1 2 heeeey2 
nl "afterHeey" prints //pause
decimal

hex
Class DLLNode
DLLNodeAlloc
: tna2x ( this | t1 )
        t1 this =  
        this p t1 p t1 @ p
        nl "this = " ps this p nl nl "t1 @ = " ps t1 @ p nl "t1 = " ps t1 p
        nl "done showing variables" ps nl
	this.nodes [ 1 ].AfterReference 1 = 
	this.nodes [ 3 ].BeforeReference 3 =
	this.nodes [ 4 ].BeforeReference 4 =
	this.nodes [ 2 ].AfterReference 2 = 
	this.nodes [ 5 ].BeforeReference 5 =
	this.nodes [ 6 ].BeforeReference 6 =
	this.nodes [ 7 ].BeforeReference 7 =
	t1 @ DLLNode.size @ 8 * dump 
;
"testA1" DLLNodeAlloc new
"testB1" DLLNodeAlloc new
nl "testA1 = " prints testA1 dup print nl tna2x //pause

Class DLLNode
DLLNodeAlloc
"testA2" DLLNodeAlloc new
"testB2" DLLNodeAlloc new
testA2.nodes [ 1 ].AfterReference 3 =
testA2.nodes [ 3 ].BeforeReference 4 =
testA2 32 dump
testA2.nodes [ 1 ].AfterReference 3 =
testA2.nodes [ 3 ].BeforeReference 4 =
testA2.nodes [ 1 ].AfterReference @ p
testA2.nodes [ 3 ].BeforeReference @ p

"before test" nl ps nl
testA2.nodes [ 3 ].BeforeReference @ 4 using Logic.== { nl "array test ok" ps } { nl "array test error" ps } tf2 nl p

testA2 32 dump
testB2.nodes [ 1 ].AfterReference 5 =
testB2.nodes [ 3 ].BeforeReference 6 =
testB2 32 dump
"testD" DLLNodeAlloc new
'testD find dobject

testD.a112.b113 77 =
"testC" 'testD find DObject.clone 
testC.a112.b113 @ dup p 77 _assert

User
hex
: _localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
;

: localsT ( t | t1 )
        t p
        t @ p
        t1 p
        t1 @ p
        t1 t @ =
        t1 @ p
        t @ _localsT
        t1 @ _localsT
;

1 localsT

Combinators User
decimal
"\n\ntesting nested locals" ps nl
: goedel { (| n ) n 1 = n @ 6 + dup 7 _assert p } ix { (| m ) m 3 = m @ 4 + dup 7 _assert p } ix ; 
'goedel find wdiss
nl "goedel :: " ps goedel sp
: goedel2 { (| n ) n 2 = n @ 5 + dup 7 "goedel2_1_assert" assert p } ix { (| n ) n @ p n 3 = n @ 4 + dup p 7 "goedel2_2_assert" assert } ix ;
nl "goedel2 :: " ps goedel2 sp
: sp s pause ;

: goedel4 (| n -- TOS ) 
    nl "goedel4 :: " ps nl
    n 9 =
    { 
        (| n ) n @ p n 2 = n @ dup p 2 "goedel4_1_assert" assert // junk 2
        { (| n ) n @ p n 3 = n @ 4 + dup p 7 "goedel4_2_assert" assert } ix // junk 7
        n @ 6 + 8 _assert 
    } ix
    { (| n ) 
        n @ p 
        n 3 =
        n dup @ 4 + // n:rvalue = 7
        dup dup 7 "goedel4_3_assert" assert // 7 7
        p
        = // store // junk 7
        n @ p n @ 7 "goedel4_4_assert" assert // 7
    } ix 
    n @ dup p // 9
;
"\ngoedel4 :: output should read : \n'junk' 2 'junk' 7 'junk' 7 7 9" ps //pause
' goedel4 find wdiss     
9 goedel4 "goedel4_0_assert" assert //pause
: goedel5 (| n -- TOS ) 
    nl "goedel5 :: " ps nl
    n 9 =
    { 
        (| n ) n @ p n 2 = n @ dup p 2 "goedel5_1_assert" assert // junk 2 n should be garbage here
        { (| n ) n @ p n 3 = n @ 4 + dup p 7 "goedel5_2_assert" assert } ix // junk 7 n should be garbage here
        n @ 6 + 8 "goedel5_3_assert" assert 
    } ix
    { (| n ) 
        n @ p // junk
        n 3 = 
        n @ 4 + n store 
        n @ dup p 7 "goedel5_4_assert" assert // 7
    } ix // n should be garbage here
    n @ dup p
;
9 goedel5 "goedel5_0_assert" assert 
"\ngoedel5 :: output should read : junk' 2 'junk' 7 7 9" ps //pause
//s pause
: goedel6 (| n -- TOS ) 
    nl "goedel6 :: " ps nl
    n 9 =
    { 
        (| n ) n @ p n 2 = n @ dup p 2 "goedel6_1_assert" assert // first n should be garbage here; second n 2
        { (| n ) n @ p n 3 = n @ 4 + dup p 7 "goedel6_2_assert" assert } ix // first n should be garbage here; second 7
        n @ 6 + 8 "goedel6_3_assert" assert 
    } ix
    { (| n ) 
        n @ p 
        n 3 = 
        n dup @ 4 + = 
        n @ dup p 7 "goedel6_4_assert" assert 
    } ix // n should be garbage here
    n @ dup p
;
//' goedel6 find wdiss pause   
9 goedel6 "goedel6_0_assert" assert
"\ngoedel6 :: goedel6 output should read : \n'junk' 2 'junk' 7 7 'junk' 9" ps //pause

: goedel7 (| n -- TOS ) 
    nl "goedel7 :: " ps nl
    n 1 =
    { 
        'n var
        n @ p n 2 = n @ dup p 2 "goedel7_1_assert" assert // first n should be garbage here; second n 2
        { 'n var n @ p n 3 = n @ 4 + dup p 7 "goedel7_2_assert" assert } ix // first n should be garbage here; second 7
        n @ 6 + 8 /
    } ix
    { 
        n 3 = 
        n 7 += 
    } ix 
    n @ 8 + dup p
;
//' goedel7 find wdiss pause   
nl "goedel7 :: " ps nl
18 goedel7 "goedel7_0_assert" assert 
"\ngoedel7 :: goedel7 output should read : \n'junk' 2 'junk' 7 18" ps //pause
#endif

2 + 7 assertStkChk // stack checking
