
5
optimizeOn inlineOn 
lispOff
bnoff 
// optimizeOff inlineOff
// verbosity 2 = 
Compiler Logic Int C User 
: sp ; //stack pause ;
var: facTest fibTest Dsp ;

// tail recursion from http://c2.com/cgi/wiki?TailCallOptimization
c_syntaxOn dscOn
int factoriali ( REG n | REG res )
{
    res = 1;
    while ( n >= 2 )
    {
#if 1
        res *= (n--) ; 
#else
        res = res * (n--) ;
#endif
    }
    return res;
} prefix
c_syntaxOff 
'factoriali find wdiss
factoriali (7) dup p 5040 _assert //pause //sp
//dscOff
: factorial ( n  | fac -- TOS ) 
    fac 1 = 
    { n @ 1 > } { n @ fac @ * fac store n -- } while 
    fac @ 
;
7 factorial dup p 5040 _assert
: qexp dup 1 <= if{ }else{ dup -- qexp * }fi ; 7 qexp dup p 5040 _assert
: qexp2 dup 1 <= ?< >:< dup -- qexp2 * >? ; 7 qexp2 dup p 5040 _assert

: bexp ( n ) n @ 1 > if{ n @ dup -- bexp * }else{ 1 }fi ; 7 bexp dup p 5040 _assert
: bexp2 ( n ) { n @ 1 > } { n @ dup -- bexp2 * } { 1 } ifElse ; 7 bexp2 dup p 5040 _assert
: bexp3 ( n ) { n @ 1 > } { n @ n @ -- bexp3 *  } { 1 } ifElse ;
7 bexp3 dup p 5040 _assert //sp
c_syntaxOn
int
faccs3 ( n | rec -- TOS ) 
{
    for ( rec = 1 ; n > 1 ; n-- )
    { 
        rec = rec * n ; 
    } 
    //return rec ;
}
' faccs3 find wdiss
faccs3 ( 7 ) dup p 5040 _assert //sp
int
fac5 ( REG n  | REG facc -- RAX ) 
{ 
    facc = 1 ;
    while ( n > 1 ) 
    {
        facc = facc * n -- ;
    }
    return facc ;
}
wdiss ( ' fac5 find ) ; 
fac5 ( 7 ) dup p 5040 _assert //sp

int
faccs ( REG n | REG rec -- RAX ) 
{
    rec = 1 ; 
    while ( n > 1 )
    { 
        rec = rec * n ;  n-- ; 
    } 
    return rec ;
}
' faccs find wdiss
faccs ( 7 ) dup p 5040 _assert //sp

int
fac5 ( REG n  | REG facc ) 
{ 
    facc = 1 ;
    while ( n > 1 ) 
    {
        facc = facc * n -- ;
    }
    return facc ;
}
//wdiss ( ' fac5 find ) 
fac5 ( 7 ) dup p 5040 _assert  // pause

int
faccs2 ( REG n | REG rec ) 
{
    for ( rec = 1 ; n > 1 ; n-- )
    { 
        rec = rec * n ; 
    } 
    return rec ;
}
' faccs2 find wdiss
faccs2 ( 7 ) dup p 5040 _assert 
c_syntaxOff

: fac ( n  | res -- TOS ) 
    res 1 = 
    { n @ 1 > } { res n @ res @ * = n -- } while 
    res @ 
;
7 fac dup p 5040 _assert 
// : bexp2 ( n | res ) { n @ 1 <= } { 1 } { n @ dup -- bexp2 * } ifElse ;

: sdbg ( j ) { stackDepth 20 > } { state regs nl "stackDepth = " ps stackDepth p nl hex { j stackDepth = } { j @ 0 > } { j -- } { p } for quit } if2 ;

User
//'dn 'dfnba find alias  
: factorial ( REG n | REG rec -- RAX ) rec 1 = { n @ 1 > } { rec @ n @ * rec store n -- } while return rec ;
: _ifx ( w | j ) 
    { j 1 = } { j @ 23 <= } { j ++ } 
    {
       //j @ w @ wordRun j @ p "." ps p ";" ps dn
       j @ w @ wordRun drop // j @ p "." ps p ";" ps
       //j @ w @ wordRun j @ p "." ps p ";" ps //pause
    }
    for 
;

: _ifx2 ( w | j k ) 
    { k 2 = j 1 = } { j @ 23 <= } { j ++ } 
    {
       //k @ j @ w @ wordRun j @ p "." ps p ";" ps
       j @ k @ w @ wordRun drop //3 ndrop pause // j @ p "." ps p ";" ps
    }
    for
;

: iFactorialX ( n w | k ) 
    { k 1 = } { k @ n @ <= } { k ++ } 
    { w @ _ifx } for 
; 
'iFactorialX find wdiss //pause
: iFactorialX2 ( n w | k ) { k 1 = } { k @ n @ <= } { k ++ } { w @ _ifx2 } for ; 
'reps var
: _ffx ( n w | t ) 
    nl 7 w @ wordRun decimal p nl 
    { t 0 = } { t @ n @ < } { t ++ } 
    { reps @ w @ iFactorialX } for 
;
'_ffx find wdiss //pause
: _ffx2 ( w n | t ) nl 2 16 w @ wordRun decimal p nl { t 0 = } { t @ n @ < } { t ++ } { reps @ w @ iFactorialX2 } for ;

nl "ffx ... " ps nl

: ffx ( wn | d ) 1 ti d wn @ _find = d @ wdiss 3 d @ _ffx nl wn @ ps ":" ps 1 time nl ;
: ffx2 ( wn | w ) 1 ti w wn @ _find = w @ wdiss w @ 3 _ffx2 1 time nl ;
c_syntaxOn
User
int
fibPTC2? ( REG n | REG fn, REG fn1, REG fn2 )
{
    for ( fn = 0, fn1 = 0, fn2 = 1 ; n ; n -- ) 
    {   
        fn1 = fn2 ;
        fn2 = fn ;
        fn = fn1 + fn2 ; 
    }
    return fn ;
}
c_syntaxOff
User
#if 1
reps 20000 =
"factorial" ffx
"cfactorial" ffx
"cfactorial2" ffx
"cfactorial3" ffx
User "qexp" ffx
C "bexp" ffx
"bexp2" ffx
"factoriali" ffx
C "qexp" ffx
C "qexp2" ffx
"bexp" ffx
"bexp2" ffx
"bexp3" ffx
"fac" ffx
"fac5" ffx //pause
User
"factorial" ffx
"cfactorial3" ffx
"cfactorial" ffx
"cfactorial2" ffx
"cfactorial3" ffx
"cfactorial_O3" ffx
"cfactorial2_O3" ffx
"cfactorial3_O3" ffx
using  
"factorial" ffx
"faccs" ffx
"fac5" ffx
"fac4" ffx
#else
: _ffx_fib ( n w | t ) nl 7 w @ wordRun decimal p nl { t 0 = } { t @ n @ < } { t ++ } { 1 w @ iFactorialX } for ;
: ffx_fib ( wn | d ) 1 ti d fibPTC2? = d @ wdiss 1 d @ _ffx_fib nl wn @ ps ":" ps 1 time nl ;
"fibPTC2?" ffx_fib
sp
#endif

//verbosity 3 =
c_syntaxOn
Root
//int cpow ( base power | out ) s{ for ( out = 1 ; power ; ( power -= 1 ) ) { out = out * base ; } return out ; }s 
int cpow ( base power | out ) { for ( out = 1 ; power ; power -= 1 ) { out = out * base ; } return out ; }
'cpow find wdiss
c_syntaxOff
2 30 cpow dup p  1073741824 _assert
#if 1
//s: pow ( base power | out -- TOS ) { out 1 = } { power @ 0 > } { power power @ 1 - = } { out out @ base @ * = } for return out @ ;s
: pow ( base power | out ) { out 1 = } { power @ 0 > } { power power @ 1 - = } { out out @ base @ * = } for return out ;
'pow find wdiss
2 30 pow dup p  1073741824 _assert 
: pow ( base power | out ) { out 1 = } { power @ 0 > } { power power @ 1 - = } { out out @ base @ * = } for return out ;
"pow" ffx2
"cpow" ffx2

Int
"**" ffx2
"pow_03" ffx2
//sp
sp
//pause

C
: tt ( | t ) t 6 = t ++ t @ p ;
nl ' tt find dup wdis definition call "\nshould show 7" ps //pause
User

c_syntaxOn
int 
_fibn0 ( n | fib ) 
{
    fib = n ;
    if ( n > 1 ) 
    {
        fib =  _fibn0 ( n - 1 ) + _fibn0 ( n - 2 ) ;
    }
    return fib ;
}
//' _fibn0 find d: wdiss sp _fibn0 ( 20 ) dup p 6765 _assert //sp
dscOn 
int
fibPTC? ( n ) //| fn, fn1, fn2 ) 
{
    int fn, fn1, fn2 ;
    for ( fn = 0, fn1 = 0, fn2 = 1 ; n ; n -- ) 
    {   
        fn1 = fn2 ;
        fn2 = fn ;
        fn = fn1 + fn2 ; 
    }
    return fn ;
}
' int.fibPTC? find wdiss
int.fibPTC? (20) dup p 6765 _assert sp
dscOff
int
fibPTC2? ( REG n | REG fn, REG fn1, REG fn2 )
{
    for ( fn = 0, fn1 = 0, fn2 = 1 ; n ; n -- ) 
    {   
        fn1 = fn2 ;
        fn2 = fn ;
        fn = fn1 + fn2 ; 
    }
    return fn ;
}
' int.fibPTC2? find wdiss
20 int.fibPTC2? dup p 6765 _assert sp 
c_syntaxOff
//"fibPTC?" ffx 
sp

: _fibn1 ( n -- TOS ) { n @ 2 < } { n @ } { n -- n @ _fibn1 n -- n @  _fibn1 + } ifElse ;
' _fibn1 find wdiss 20 _fibn1 p // sp
: _fib1 ( n ) { n @ 2 < } { n @ } { n @ -- _fib1 n @ 2 - _fib1 + } ifElse ;
sp
#if 1 // to be fixed? - not priority
: sp stack pause ;    
: _fib 
    dup 2 <  
    if{ 
    }else{ 
        dup -- _fib swap 2 - _fib + 
    }fi 
;
20 _fib p //sp
: _fib2 dup 2 < ?< >:< dup -- _fib2 swap 2 - _fib2 + >; ; 20 _fib2 p //sp

: _fib3 
    dup 2 < 
    ?< >:< 
        dup -- _fib3 swap 2 - _fib3 + 
    >; 
;
' _fib3 find wdiss 
20 _fib3 p //sp
: _fib4 
    { dup 2 >= }
    { 
        dup -- _fib4 swap 2 - _fib4 + 
    } if2 
;
' _fib4 find wdiss
20 _fib4 p 
: sp ;
#endif
sp
Locals
"fib1" ( n ) { 1 ti n @ _fib1 p 1 time } word
C
'cfib2_O3 find wdiss //sp
#if 1
: fib  ( n ) 1 ti n @ _fib  p 1 time ;
: fib2 ( n ) 1 ti n @ _fib2 p 1 time ;
: fib3 ( n ) 1 ti n @ _fib3 p 1 time ;
: fib4 ( n ) 1 ti n @ _fib4 p 1 time ;
#endif
: fibn0 ( n ) 1 ti n @ _fibn0 p 1 time ;
: Cfib ( n ) 1 ti n @ cfib  p 1 time ;
: Cfib_O3 ( n ) 1 ti n @ cfib_O3  p 1 time ;
: fibPTC ( n ) 1 ti n @ fibPTC?  p 1 time ;
: fibPTC2 ( n ) 1 ti n @ fibPTC2?  p 1 time ;
: tfib ( n )  
    nl hex dsp p decimal nl "The fibonacci sequence" ps n @ p ":" ps nl 
    "C -O3 : " ps n @ Cfib_O3 nl 
#if 1        
    "no locals fib  : " ps n @ fib nl 
    //"locals fibn0 : " ps n @ fibn0 nl 
    "locals fib1  : " ps n @ fib1 nl 
    "no locals fib2 : " ps n @ fib2 nl
    "no locals fib3 : " ps n @ fib3 nl
#endif        
    "fibPTC?        : " ps n @ fibPTC nl
    "fibPTC2?        : " ps n @ fibPTC2
;
sp
15 tfib 30 tfib //40 tfib //45 tfib 
sp
: tfib1 ( n | m )  
    nl "The fibonacci sequence:: first :" ps n @ p "..." ps nl 
    "Cfib_O3         : " ps 1 ti m 1 = { m @ n @ < } { m @ cfib_O3 p m ++ } while 1 time nl nl
    "Cfib            : " ps 1 ti m 1 = { m @ n @ < } { m @ cfib    p m ++ } while 1 time nl nl
    "Cfib_O3         : " ps 1 ti m 1 = { m @ n @ < } { m @ cfib_O3 p m ++ } while 1 time nl nl
    "no locals _fib  : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib    p m ++ } while 1 time nl nl 
    "locals   _fibn0 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fibn0  p m ++ } while 1 time nl nl
    "locals   _fibn1 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fibn1  p m ++ } while 1 time nl nl
    "locals   _fib1  : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib1   p m ++ } while 1 time nl nl
    "no locals _fib2 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib2   p m ++ } while 1 time nl nl
    "no locals _fib3 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib3   p m ++ } while 1 time nl nl
    "no locals _fib4 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib4   p m ++ } while 1 time nl nl
    "fibPTC?  : " ps 1 ti m 1 = { m @ n @ < } { m @ fibPTC? p m ++ } while 1 time nl nl
    "fibPTC2?  : " ps 1 ti m 1 = { m @ n @ < } { m @ fibPTC2? p m ++ } while 1 time nl nl
;

: tfib2 ( n | m )  
    "Cfib_O3        : " ps 1 ti m 1 = { m @ n @ < } { m @ cfib_O3 p m ++ } while 1 time nl nl
    "no locals _fib4 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib4 p m ++ } while 1 time nl nl
    "locals _fibn1   : " ps 1 ti m 1 = { m @ n @ < } { m @ _fibn1 p m ++ } while 1 time nl nl
    "no locals _fib3 : " ps 1 ti m 1 = { m @ n @ < } { m @ _fib3 p m ++ } while 1 time nl nl
;
: tfib3 ( n | m )  
    "Cfib2_O3       : " ps 1 ti m 1 = { m @ n @ <= } { m @ cfib2_O3 p m ++ } while 1 time nl nl
    "locals fibPTC? : " ps 1 ti m 1 = { m @ n @ <= } { m @ fibPTC? p m ++ } while 1 time nl nl
    "locals fibPTC2? : " ps 1 ti m 1 = { m @ n @ <= } { m @ fibPTC2? p m ++ } while 1 time nl nl
;
//' tfib1 find d: wdiss sp pause
30 tfib1
30 tfib2
' tfib3 find wdiss //pause
92 tfib3 //sp
//: fibx ( n ) { n @ 0 >= } { n @ _fib p n -- } while ;
//: fibx2 ( n | m ) "fibonacci" ps n @ p ":" ps m 0 = { m @ n @ < n @ <= } { m @ n @ < _fib2 p m ++ } while ;
// : fibx3 ( n | m ) "fibonacci" ps n @ p ":" ps m 0 = { m @ n @ < n @ <= } { m @ n @ < _fib3 p m ++ } while ;
//: fibx3 ( n ) "fibonacci" ps n @ p ":" ps { n @  } { n @ _fib3 p n -- } while ;
// ' _fib find wdiss
' _fib2 find wdiss
// 40 fibx3 
sp
bnon
: tbn ( | n m ) n 0 = m 3 = n m @ += n m @ += n m @ += n @ p ; tbn nl "should be 9" ps
s: fibBN ( n | fn fn1 fn2 -- TOS ) 
    { fn 0 = fn1 0 = fn2 1 = } { n @ 0 > } { n 1 -= } 
    {   
        fn1 fn2 @ = 
        fn2 fn @ = 
        fn fn1 @ fn2 @ + = 
    }
    for
    // nl svn @ fprint ":" ps fn @ fprint 
    fn @
;s
' fibBN find wdiss
20 fibBN p 
: tfib3 ( n | m )  
    "locals fibBN : " ps 
    { m 1 = } { m @ n @ <= } { m 1 +=  } 
    { m @ dup p " : " _ps fibBN p { n @ m @ > } { "," _ps } if2 } 
    for
;
//nl nl 47 tfib3 //sp pause
nl nl 100 tfib3 //sp pause
nl 100 dup p fibBN p //sp
bnoff //pause

nl
// verbosity 1 =
namespaceTreeWithWords

2 + 7 assertStkChk // stack checking
s

